
digraph G {
  rankdir=TB; // Change layout to Top-to-Bottom
  nodesep=0.5; // Adjust horizontal spacing
  ranksep=1;   // Adjust vertical spacing
  node [fontname="Arial"];
  "app-test.ts" [shape=box];
  "app.ts" [shape=box];
  "controllers" [shape=folder];
  "assistant.controller.ts" [shape=box];
  "res.status(500).json({ error: (error as Error).message })" [shape=hexagon];
  "res.status(201).json({ id })" [shape=hexagon];
  "res.status(400).json({ error: (error as Error).message })" [shape=hexagon];
  "data" [shape=folder];
  "database" [shape=folder];
  "database.ts" [shape=box];
  "init.ts" [shape=box];
  "index.ts" [shape=box];
  "models" [shape=folder];
  "assistant.model.ts" [shape=box];
  "feedback.model.ts" [shape=box];
  "focused-memory.model.ts" [shape=box];
  "memory.model.ts" [shape=box];
  "promotion-criteria.model.ts" [shape=box];
  "relationship.model.ts" [shape=box];
  "service-models" [shape=folder];
  "connector.service.model.ts" [shape=box];
  "tag.model.ts" [shape=box];
  "task.model.ts" [shape=box];
  "queries" [shape=folder];
  "assistant.queries.ts" [shape=box];
  "buildGetAssistantWithFiltersQuery({ type: 'chat', tags: ['ai', 'assistant'] })" [shape=hexagon];
  "routes" [shape=folder];
  "assistant.routes.ts" [shape=box];
  "services" [shape=folder];
  "assistant-full.service.ts" [shape=box];
  "fullAssistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch full assistant details using individual queries.
   */
  async getFullAssistantWithDetails(id: string): Promise<AssistantWithDetails | null> {
    try {
      // Fetch assistant details
      const assistantRow = this.db
        .prepare(
          `
      SELECT * 
      FROM assistants 
      WHERE id = ?
    `
        )
        .get(id) as AssistantRow | undefined;

      if (!assistantRow) return null;

      // Fetch assistant tags
      const assistantTagRows = this.db
        .prepare(
          `
      SELECT t.* 
      FROM assistant_tags at
      JOIN tags t ON at.tag_id = t.id
      WHERE at.assistant_id = ?
    `
        )
        .all(id) as TagRow[];

      // Fetch memory focus rule
      const memoryFocusRuleRow = this.db
        .prepare(
          `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
        )
        .get(id) as MemoryFocusRuleRow | undefined;

      // Fetch related focused memories if a focus rule exists
      const memoryRows = memoryFocusRuleRow
        ? (this.db
            .prepare(
              `
          SELECT m.*, t.id AS tag_id, t.name AS tag_name
          FROM focused_memories fm
          JOIN memories m ON fm.memory_id = m.id
          LEFT JOIN memory_tags mt ON m.id = mt.memory_id
          LEFT JOIN tags t ON mt.tag_id = t.id
          WHERE fm.memory_focus_id = ?
        `
            )
            .all(memoryFocusRuleRow.id) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[])
        : [];

      // Group tags by memory ID
      const memoryTags: Record<string, Tag[]> = {};
      memoryRows.forEach((row) => {
        if (!memoryTags[row.id]) {
          memoryTags[row.id] = [];
        }
        if (row.tag_id && row.tag_name) {
          memoryTags[row.id].push({ id: row.tag_id, name: row.tag_name });
        }
      });

      // Fetch feedback summary for the assistant
      const feedbackSummaryRow = this.db
        .prepare(
          `
      SELECT 
        COALESCE(AVG(f.rating), 0) AS avgRating, 
        COALESCE(COUNT(f.id), 0) AS totalFeedback
      FROM feedback f
      JOIN tasks t ON f.target_id = t.id AND f.target_type = 'task'
      WHERE t.assignedAssistant = ?
    `
        )
        .get(id) as FeedbackSummaryRow;

      // Transform and return the AssistantWithDetails object
      return transformAssistantWithDetails(assistantRow, memoryRows, memoryTags, assistantTagRows, memoryFocusRuleRow, feedbackSummaryRow);
    } catch (error) {
      console.error('Error fetching full assistant details:', error);
      throw new Error('Failed to fetch assistant details.');
    }
  },

  /**
   * Fetch full assistant details using an efficient single query.
   */
  async getFullAssistantWithDetailsEfficient(id: string): Promise<AssistantWithDetails | null> {
    try {
      const rows = this.db.prepare(GET_FULL_ASSISTANT_WITH_DETAILS).all(id) as FullAssistantRows[];
      if (rows.length === 0) return null;

      return transformFullAssistantResult(rows);
    } catch (error) {
      console.error('Error transforming full assistant details:', error);
      throw new Error('Failed to fetch assistant details efficiently.');
    }
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getFullAssistantWithDetails" [shape=ellipse];
  "getFullAssistantWithDetailsEfficient" [shape=ellipse];
  "memoryTags: Record<string, Tag[]> = {}" [shape=hexagon];
  "memoryTags[row.id].push({ id: row.tag_id, name: row.tag_name })" [shape=hexagon];
  "assistant.service.ts" [shape=box];
  "assistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  // Fetch all assistants
  getAllAssistants(): AssistantRow[] {
    const stmt = this.db.prepare('SELECT * FROM assistants');
    return stmt.all() as AssistantRow[];
  },

  // Fetch a single assistant by ID
  getAssistantById(id: string): AssistantRow | null {
    const stmt = this.db.prepare('SELECT * FROM assistants WHERE id = ?');
    const result = stmt.get(id);
    return result ? (result as AssistantRow) : null;
  },

  // Add a new assistant
  async addAssistant(assistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the assistant
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO assistants (id, name, description, type, instructions, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, assistant.name, assistant.description, assistant.type, assistant.instructions || null, createdAt, updatedAt);

    return id;
  },

  // Update an existing assistant
  async updateAssistant(id: string, updates: Partial<Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingAssistant = this.db.prepare('SELECT * FROM assistants WHERE id = ?').get(id) as AssistantRow | undefined;

    if (!existingAssistant) {
      throw new Error(`Assistant with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE assistants
      SET
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        type = COALESCE(?, type),
        instructions = COALESCE(?, instructions),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.name || null,
      updates.description || null,
      updates.type || null,
      updates.instructions || null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete an assistant by ID
  async deleteAssistant(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM assistants
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the assistant was deleted
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getAllAssistants" [shape=ellipse];
  "getAssistantById" [shape=ellipse];
  "addAssistant" [shape=ellipse];
  "updateAssistant" [shape=ellipse];
  "deleteAssistant" [shape=ellipse];
  "feedback.service.ts" [shape=box];
  "feedbackService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb;
  },

  getFeedbackById(id: string): Feedback | null {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE id = ?');
    const result = stmt.get(id) as FeedbackRow;

    if (!result) return null;

    // Map database fields to Feedback interface
    return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };
  },

  getFeedbackByTarget(targetId: string, targetType: 'assistant' | 'memory' | 'task'): Feedback[] {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE target_id = ? AND target_type = ?');
    const results = stmt.all(targetId, targetType) as FeedbackRow[];

    // Map database fields to Feedback interface
    return results.map((result) => ({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    }));
  },

  async addFeedback(feedback: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO feedback (id, target_id, target_type, user_id, rating, comments, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, feedback.targetId, feedback.targetType, feedback.userId || null, feedback.rating, feedback.comments || null, createdAt, updatedAt);

    return id;
  },

  async updateFeedback(id: string, updates: Partial<Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingFeedback = this.db.prepare('SELECT * FROM feedback WHERE id = ?').get(id);

    if (!existingFeedback) {
      throw new Error(`Feedback with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE feedback
      SET
        target_id = COALESCE(?, target_id),
        target_type = COALESCE(?, target_type),
        user_id = COALESCE(?, user_id),
        rating = COALESCE(?, rating),
        comments = COALESCE(?, comments),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.targetId || null, updates.targetType || null, updates.userId || null, updates.rating || null, updates.comments || null, new Date().toISOString(), id);

    return true;
  },

  async deleteFeedback(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM feedback WHERE id = ?');
    const result = stmt.run(id);

    return result.changes > 0;
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getFeedbackById" [shape=ellipse];
  "getFeedbackByTarget" [shape=ellipse];
  "addFeedback" [shape=ellipse];
  "updateFeedback" [shape=ellipse];
  "deleteFeedback" [shape=ellipse];
  "return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };" [shape=hexagon];
  "({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })" [shape=hexagon];
  "focused-memory.service.ts" [shape=box];
  "focusedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getFocusedMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM memory_focus_rules fr
      JOIN focused_memories fm ON fr.id = fm.memory_focus_id
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fr.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getFocusedMemories(memoryFocusId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM focused_memories fm
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fm.memory_focus_id = ?
    `
      )
      .all(memoryFocusId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async addFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0; // Returns true if the memory was successfully added
    } catch {
      return false; // Gracefully handle duplicates or constraint violations
    }
  },
  async removeFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM focused_memories
      WHERE memory_focus_id = ? AND memory_id = ?
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0;
    } catch {
      return false;
    }
  },
  async updateFocusedMemories(memoryFocusId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
    DELETE FROM focused_memories
    WHERE memory_focus_id = ?
  `);

      const insertStmt = this.db.prepare(`
    INSERT INTO focused_memories (memory_focus_id, memory_id)
    VALUES (?, ?)
  `);

      // Remove all existing associations
      deleteStmt.run(memoryFocusId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(memoryFocusId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getFocusedMemoriesByAssistantId" [shape=ellipse];
  "getFocusedMemories" [shape=ellipse];
  "addFocusedMemory" [shape=ellipse];
  "removeFocusedMemory" [shape=ellipse];
  "updateFocusedMemories" [shape=ellipse];
  "memoryMap.set(row.id, { row, tags: [] })" [shape=hexagon];
  "memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name })" [shape=hexagon];
  "memoryMap.set(row.id, { row, tags: [] })" [shape=hexagon];
  "memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name })" [shape=hexagon];
  "gpt-api" [shape=folder];
  "gpt-api-assistant.ts" [shape=box];
  "createAssistant" [shape=diamond];
  "getAssistantById" [shape=diamond];
  "updateAssistant" [shape=diamond];
  "deleteAssistant" [shape=diamond];
  "params: AssistantCreateParams = {
      model: payload.model, // Required
      ...(payload.instructions ? { instructions: payload.instructions } : {}),
      ...(payload.name ? { name: payload.name } : {}),
      ...(payload.description !== undefined ? { description: payload.description } : {}),
      ...(payload.tools && payload.tools.length > 0 ? { tools: payload.tools } : {}),
      ...(payload.metadata ? { metadata: payload.metadata } : {}),
      ...(payload.temperature !== undefined ? { temperature: payload.temperature } : {}),
      ...(payload.top_p !== undefined ? { top_p: payload.top_p } : {}),
      ...(payload.response_format ? { response_format: payload.response_format } : {}),
    }" [shape=hexagon];
  "payload.instructions ? { instructions: payload.instructions } : {}" [shape=hexagon];
  "payload.instructions ? { instructions: payload.instructions } : {}" [shape=hexagon];
  "payload.name ? { name: payload.name } : {}" [shape=hexagon];
  "payload.name ? { name: payload.name } : {}" [shape=hexagon];
  "payload.description !== undefined ? { description: payload.description } : {}" [shape=hexagon];
  "payload.description !== undefined ? { description: payload.description } : {}" [shape=hexagon];
  "payload.tools && payload.tools.length > 0 ? { tools: payload.tools } : {}" [shape=hexagon];
  "payload.tools && payload.tools.length > 0 ? { tools: payload.tools } : {}" [shape=hexagon];
  "payload.metadata ? { metadata: payload.metadata } : {}" [shape=hexagon];
  "payload.metadata ? { metadata: payload.metadata } : {}" [shape=hexagon];
  "payload.temperature !== undefined ? { temperature: payload.temperature } : {}" [shape=hexagon];
  "payload.temperature !== undefined ? { temperature: payload.temperature } : {}" [shape=hexagon];
  "payload.top_p !== undefined ? { top_p: payload.top_p } : {}" [shape=hexagon];
  "payload.top_p !== undefined ? { top_p: payload.top_p } : {}" [shape=hexagon];
  "payload.response_format ? { response_format: payload.response_format } : {}" [shape=hexagon];
  "payload.response_format ? { response_format: payload.response_format } : {}" [shape=hexagon];
  "gpt-api-chat-completion.ts" [shape=box];
  "createChatCompletion" [shape=diamond];
  "extractChatReply" [shape=diamond];
  "generateChatReply" [shape=diamond];
  "extendConversation" [shape=diamond];
  "options: {
    max_tokens?: number;
    temperature?: number;
    top_p?: number;
    n?: number;
    stop?: string | string[];
    user?: string;
    store?: boolean;
  } = {}" [shape=hexagon];
  "openai.chat.completions.create({
      model,
      messages,
      max_tokens: options.max_tokens ?? 100,
      temperature: options.temperature ?? 0.7,
      top_p: options.top_p ?? 1,
      n: options.n ?? 1,
      stop: options.stop ?? null,
      user: options.user ?? undefined,
      store: options.store ?? false,
    })" [shape=hexagon];
  "options: {
    max_tokens?: number;
    temperature?: number;
    top_p?: number;
    stop?: string | string[];
    user?: string;
    store?: boolean;
  } = {}" [shape=hexagon];
  "gpt-api-connector.ts" [shape=box];
  "initOpenAI" [shape=diamond];
  "getOpenAI" [shape=diamond];
  "new OpenAI({
    apiKey,
    project,
  })" [shape=hexagon];
  "gpt-api-model-helper.ts" [shape=box];
  "evaluatePrompt" [shape=diamond];
  "estimateTokens" [shape=diamond];
  "getSuitableModels" [shape=diamond];
  "estimateTokensFromWords" [shape=diamond];
  "estimateTokensForResponse" [shape=diamond];
  "estimateTokensFromPrompt" [shape=diamond];
  "models: Record<string, Model> = {
  'gpt-4o': {
    alias: 'gpt-4o',
    contextWindow: 128000,
    maxOutputTokens: 16384,
    description: 'High-intelligence, versatile flagship model.',
    useCase: 'Complex tasks, research, structured outputs.',
  },
  'gpt-4o-mini': {
    alias: 'gpt-4o-mini',
    contextWindow: 128000,
    maxOutputTokens: 16384,
    description: 'Fast, affordable, smaller model.',
    useCase: 'Cost-effective tasks, fine-tuning.',
  },
  o1: {
    alias: 'o1',
    contextWindow: 200000,
    maxOutputTokens: 100000,
    description: 'Advanced reasoning with step-by-step logic.',
    useCase: 'Solving hard problems, detailed reasoning.',
  },
  'o1-mini': {
    alias: 'o1-mini',
    contextWindow: 128000,
    maxOutputTokens: 65536,
    description: 'Affordable reasoning for specialized tasks.',
    useCase: 'Fast reasoning, smaller contexts.',
  },
  'gpt-4-turbo': {
    alias: 'gpt-4-turbo',
    contextWindow: 128000,
    maxOutputTokens: 4096,
    description: 'Optimized for cost and shorter responses.',
    useCase: 'Budget-friendly conversational tasks.',
  },
  'gpt-3.5-turbo-16k': {
    alias: 'gpt-3.5-turbo-16k',
    contextWindow: 16385,
    maxOutputTokens: 4096,
    description: 'Economical, fast, and reliable.',
    useCase: 'Lightweight, budget-friendly tasks.',
  },
}" [shape=hexagon];
  "'gpt-4o': {
    alias: 'gpt-4o',
    contextWindow: 128000,
    maxOutputTokens: 16384,
    description: 'High-intelligence, versatile flagship model.',
    useCase: 'Complex tasks, research, structured outputs.',
  }" [shape=hexagon];
  "'gpt-4o-mini': {
    alias: 'gpt-4o-mini',
    contextWindow: 128000,
    maxOutputTokens: 16384,
    description: 'Fast, affordable, smaller model.',
    useCase: 'Cost-effective tasks, fine-tuning.',
  }" [shape=hexagon];
  "o1: {
    alias: 'o1',
    contextWindow: 200000,
    maxOutputTokens: 100000,
    description: 'Advanced reasoning with step-by-step logic.',
    useCase: 'Solving hard problems, detailed reasoning.',
  }" [shape=hexagon];
  "'o1-mini': {
    alias: 'o1-mini',
    contextWindow: 128000,
    maxOutputTokens: 65536,
    description: 'Affordable reasoning for specialized tasks.',
    useCase: 'Fast reasoning, smaller contexts.',
  }" [shape=hexagon];
  "'gpt-4-turbo': {
    alias: 'gpt-4-turbo',
    contextWindow: 128000,
    maxOutputTokens: 4096,
    description: 'Optimized for cost and shorter responses.',
    useCase: 'Budget-friendly conversational tasks.',
  }" [shape=hexagon];
  "'gpt-3.5-turbo-16k': {
    alias: 'gpt-3.5-turbo-16k',
    contextWindow: 16385,
    maxOutputTokens: 4096,
    description: 'Economical, fast, and reliable.',
    useCase: 'Lightweight, budget-friendly tasks.',
  }" [shape=hexagon];
  "return {
    estimatedInputTokens: inputTokens,
    requiredOutputTokens: outputTokens,
    intelligenceLevel: intelligence,
    suggestedModel: selectedModel.alias,
    availableResponseTokens,
    isFeasible,
    recommendations,
  };" [shape=hexagon];
  "responseWordEstimates: Record<typeof responseSize, number> = {
    sentence: 20, // Approx. 20 words per sentence
    paragraph: 150, // Approx. 150 words per paragraph
    page: 300, // Approx. 300 words per page
    'multi-page': 1000, // Approx. 1000 words for multi-page responses
  }" [shape=hexagon];
  "return { inputTokens, outputTokens, totalTokens };" [shape=hexagon];
  "gpt-api-models.model.ts" [shape=box];
  "gpt-api-thread.ts" [shape=box];
  "createNewThread" [shape=diamond];
  "addThreadMessage" [shape=diamond];
  "addMultipleMessages" [shape=diamond];
  "fetchThreadMessages" [shape=diamond];
  "startAssistantRun" [shape=diamond];
  "waitForRunCompletion" [shape=diamond];
  "getRunDetails" [shape=diamond];
  "extractAssistantReply" [shape=diamond];
  "getAssistantReply" [shape=diamond];
  "queryAssistant" [shape=diamond];
  "openai.beta.threads.create({
      metadata: { purpose, created_by: createdBy },
    })" [shape=hexagon];
  "metadata: { purpose, created_by: createdBy }" [shape=hexagon];
  "openai.beta.threads.messages.create(threadId, { role, content })" [shape=hexagon];
  "openai.beta.threads.messages.list(threadId, { limit, order })" [shape=hexagon];
  "openai.beta.threads.runs.create(threadId, { assistant_id: assistantId, instructions })" [shape=hexagon];
  "openai.beta.threads.runs.createAndPoll(threadId, { assistant_id: assistantId, instructions })" [shape=hexagon];
  "gpt-api.config.ts" [shape=box];
  "memory-extra.service.ts" [shape=box];
  "memoryExtraService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch all memories with their associated tags.
   */
  async getAllMemories(): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
      `
      )
      .all() as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Fetch memories associated with specific tags.
   */
  async getMemoriesByTags(tags: string[]): Promise<Memory[]> {
    if (tags.length === 0) {
      throw new Error('Tags array cannot be empty.');
    }

    const placeholders = tags.map(() => '?').join(', ');
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
        WHERE t.name IN (${placeholders})
      `
      )
      .all(...tags) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Update tags associated with a memory.
   */
  async updateMemoryTags(memoryId: string, newTags: string[]): Promise<boolean> {
    // Ensure memory exists
    const memoryRow = this.db
      .prepare(
        `
      SELECT * 
      FROM memories 
      WHERE id = ?
    `
      )
      .get(memoryId) as MemoryRow | undefined;

    if (!memoryRow) {
      throw new Error(`Memory with ID ${memoryId} not found.`);
    }

    // Fetch existing tags for the memory
    const existingTags = this.db
      .prepare(
        `
      SELECT t.name 
      FROM memory_tags mt
      JOIN tags t ON mt.tag_id = t.id
      WHERE mt.memory_id = ?
    `
      )
      .all(memoryId) as { name: string }[];

    const currentTagNames = existingTags.map((tag) => tag.name);
    const tagsToAdd = newTags.filter((tagName) => !currentTagNames.includes(tagName));
    const tagsToRemove = currentTagNames.filter((tagName) => !newTags.includes(tagName));

    // Add new tags
    for (const tagName of tagsToAdd) {
      // Ensure the tag exists
      let tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (!tag) {
        const newTagId = generateUniqueId();
        this.db
          .prepare(
            `
        INSERT INTO tags (id, name)
        VALUES (?, ?)
      `
          )
          .run(newTagId, tagName);
        tag = { id: newTagId };
      }

      // Associate the tag with the memory
      this.db
        .prepare(
          `
      INSERT OR IGNORE INTO memory_tags (memory_id, tag_id)
      VALUES (?, ?)
    `
        )
        .run(memoryId, tag.id);
    }

    // Remove old tags
    for (const tagName of tagsToRemove) {
      const tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (tag) {
        this.db
          .prepare(
            `
        DELETE FROM memory_tags 
        WHERE memory_id = ? AND tag_id = ?
      `
          )
          .run(memoryId, tag.id);
      }
    }

    return true;
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getAllMemories" [shape=ellipse];
  "getMemoriesByTags" [shape=ellipse];
  "updateMemoryTags" [shape=ellipse];
  "memoryMap.set(row.id, { row, tags: [] })" [shape=hexagon];
  "memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name })" [shape=hexagon];
  "memoryMap.set(row.id, { row, tags: [] })" [shape=hexagon];
  "memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name })" [shape=hexagon];
  "tag = { id: newTagId }" [shape=hexagon];
  "memory-focus-rule.service.ts" [shape=box];
  "memoryFocusRuleService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoryFocusRules(assistantId: string): Promise<MemoryFocusRule | null> {
    const row = this.db
      .prepare(
        `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
      )
      .get(assistantId) as MemoryFocusRuleRow | undefined;

    return row ? transformMemoryFocusRuleRow(row) : null;
  },
  async updateMemoryFocusRule(id: string, updates: Partial<Omit<MemoryFocusRule, 'id' | 'assistantId' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const stmt = this.db.prepare(`
      UPDATE memory_focus_rules
      SET 
        maxResults = COALESCE(?, maxResults),
        relationshipTypes = COALESCE(?, relationshipTypes),
        priorityTags = COALESCE(?, priorityTags),
        updatedAt = ?
      WHERE id = ?
    `);

    const result = stmt.run(
      updates.maxResults || null,
      updates.relationshipTypes ? JSON.stringify(updates.relationshipTypes) : null,
      updates.priorityTags ? JSON.stringify(updates.priorityTags) : null,
      new Date().toISOString(),
      id
    );

    return result.changes > 0; // Returns true if the rule was updated
  },
  async removeMemoryFocusRule(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM memory_focus_rules
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the rule was removed
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getMemoryFocusRules" [shape=ellipse];
  "updateMemoryFocusRule" [shape=ellipse];
  "removeMemoryFocusRule" [shape=ellipse];
  "memory.service.ts" [shape=box];
  "memoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async addMemory(memory: Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
    INSERT INTO memories (id, type,  description, data, createdAt, updatedAt)
    VALUES (?, ?, ?, ?, ?, ?)
  `);

    stmt.run(id, memory.type, memory.description || null, memory.data ? JSON.stringify(memory.data) : null, createdAt, updatedAt);

    return id;
  },

  async removeMemory(memoryId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM memories WHERE id = ?');
    stmt.run(memoryId);
  },

  async updateMemory(id: string, updates: Partial<Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>>): Promise<void> {
    const stmt = this.db.prepare(`
    UPDATE memories
    SET
      type = COALESCE(?, type),
      description = COALESCE(?, description),
      data = COALESCE(?, data),
      updatedAt = ?
    WHERE id = ?
  `);

    stmt.run(updates.type || null, updates.description || null, updates.data ? JSON.stringify(updates.data) : null, new Date().toISOString(), id);
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "addMemory" [shape=ellipse];
  "removeMemory" [shape=ellipse];
  "updateMemory" [shape=ellipse];
  "owned-memory.service.ts" [shape=box];
  "ownedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getOwnedMemories(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  async addOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async removeOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ? AND memory_id = ?
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async updateOwnedMemories(assistantId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ?
    `);

      const insertStmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      // Remove all existing associations
      deleteStmt.run(assistantId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(assistantId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getMemoriesByAssistantId" [shape=ellipse];
  "getOwnedMemories" [shape=ellipse];
  "addOwnedMemory" [shape=ellipse];
  "removeOwnedMemory" [shape=ellipse];
  "updateOwnedMemories" [shape=ellipse];
  "memoryMap.set(row.id, { row, tags: [] })" [shape=hexagon];
  "memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name })" [shape=hexagon];
  "memoryMap.set(row.id, { row, tags: [] })" [shape=hexagon];
  "memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name })" [shape=hexagon];
  "relationship-graph.service.ts" [shape=box];
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getAllRelationships" [shape=ellipse];
  "getRelationshipsBySource" [shape=ellipse];
  "addRelationship" [shape=ellipse];
  "updateRelationship" [shape=ellipse];
  "deleteRelationship" [shape=ellipse];
  "transformRow" [shape=ellipse];
  "return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };" [shape=hexagon];
  "tag-extra.service.ts" [shape=box];
  "tagExtraService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override the database instance
  },

  // Fetch tags associated with an entity
  getTagsByEntity(entityId: string, entityType: 'memory' | 'assistant' | 'task'): Tag[] {
    const tableName = this.getTableNameForEntity(entityType);
    const stmt = this.db.prepare(`
      SELECT t.* 
      FROM ${tableName} et
      JOIN tags t ON et.tag_id = t.id
      WHERE et.${entityType}_id = ?
    `);
    return stmt.all(entityId) as Tag[];
  },

  // Associate a tag with an entity
  async addTagToEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      INSERT INTO ${tableName} (${entityType}_id, tag_id)
      VALUES (?, ?)
    `);

    try {
      stmt.run(entityId, tagId);
      return true;
    } catch (error) {
      console.error('Error adding tag to entity:', error);
      return false;
    }
  },

  // Remove a tag from an entity
  async removeTagFromEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      DELETE FROM ${tableName}
      WHERE ${entityType}_id = ? AND tag_id = ?
    `);

    const result = stmt.run(entityId, tagId);
    return result.changes > 0;
  },

  // Utility: Map entity type to table name
  getTableNameForEntity(entityType: 'memory' | 'assistant' | 'task'): string {
    const tableMap = {
      memory: 'memory_tags',
      assistant: 'assistant_tags',
      task: 'task_tags',
    };
    return tableMap[entityType];
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getTagsByEntity" [shape=ellipse];
  "addTagToEntity" [shape=ellipse];
  "removeTagFromEntity" [shape=ellipse];
  "getTableNameForEntity" [shape=ellipse];
  "tableMap = {
      memory: 'memory_tags',
      assistant: 'assistant_tags',
      task: 'task_tags',
    }" [shape=hexagon];
  "tag.service.ts" [shape=box];
  "tagService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  /**
   * Add a new tag.
   */
  async addTag(tag: Omit<Tag, 'id'>): Promise<string> {
    const id = generateUniqueId();

    const stmt = this.db.prepare(`
      INSERT INTO tags (id, name)
      VALUES (?, ?)
    `);

    stmt.run(id, tag.name);

    return id;
  },

  /**
   * Remove a tag by ID.
   */
  async removeTag(tagId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM tags WHERE id = ?');
    stmt.run(tagId);
  },

  /**
   * Update an existing tag.
   */
  async updateTag(id: string, updates: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const stmt = this.db.prepare(`
      UPDATE tags
      SET name = COALESCE(?, name)
      WHERE id = ?
    `);

    stmt.run(updates.name || null, id);
  },

  /**
   * Fetch a tag by ID.
   */
  async getTagById(tagId: string): Promise<Tag | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags WHERE id = ?
    `);

    const result = stmt.get(tagId);
    return result ? (result as Tag) : null;
  },

  /**
   * Fetch all tags.
   */
  async getAllTags(): Promise<Tag[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags
    `);

    return stmt.all() as Tag[];
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "addTag" [shape=ellipse];
  "removeTag" [shape=ellipse];
  "updateTag" [shape=ellipse];
  "getTagById" [shape=ellipse];
  "getAllTags" [shape=ellipse];
  "task.service.ts" [shape=box];
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" [shape=hexagon];
  "setDb" [shape=ellipse];
  "getTaskById" [shape=ellipse];
  "getAllTasks" [shape=ellipse];
  "addTask" [shape=ellipse];
  "updateTask" [shape=ellipse];
  "deleteTask" [shape=ellipse];
  "getTasksByStatus" [shape=ellipse];
  "getTasksByAssistant" [shape=ellipse];
  "{
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task" [shape=hexagon];
  "({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })" [shape=hexagon];
  "unique-id.service.ts" [shape=box];
  "generateUniqueId" [shape=diamond];
  "tests" [shape=folder];
  "integration" [shape=folder];
  "gpt-api-chat-completion.integration.test.ts" [shape=box];
  "[
      { role: 'developer', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Write a haiku about recursion in programming.' },
    ]" [shape=hexagon];
  "[
      { role: 'developer', content: 'You are a helpful assistant.' },
      { role: 'user', content: 'Write a haiku about recursion in programming.' },
    ]" [shape=hexagon];
  "createChatCompletion(model, messages, { max_tokens: 50 })" [shape=hexagon];
  "[
      { role: 'developer', content: 'You are an expert on JavaScript.' },
      { role: 'user', content: 'What are closures in JavaScript?' },
    ]" [shape=hexagon];
  "[
      { role: 'developer', content: 'You are an expert on JavaScript.' },
      { role: 'user', content: 'What are closures in JavaScript?' },
    ]" [shape=hexagon];
  "generateChatReply(model, conversationHistory, { max_tokens: 50 })" [shape=hexagon];
  "[{ role: 'assistant', content: reply }]" [shape=hexagon];
  "gpt-assistant.integration.test.ts" [shape=box];
  "functionParameters: FunctionParameters = {
    lalala: () => {
      return 'trololol';
    },
  }" [shape=hexagon];
  "lalala" [shape=ellipse];
  "functionTool: FunctionTool = {
    function: {
      name: 'singAsong',
      parameters: functionParameters,
    },
    type: 'function',
  }" [shape=hexagon];
  "function: {
      name: 'singAsong',
      parameters: functionParameters,
    }" [shape=hexagon];
  "examplePayload: GptAssistantCreateRequest = {
    model: 'gpt-4o',
    instructions: 'You are a helpful assistant for testing.',
    name: 'Test Assistant 999',
    description: 'This assistant is created for testing purposes.',
    tools: [tool],
    metadata: { category: 'integration-test' },
    temperature: 0.7,
    top_p: 0.9,
    response_format: 'auto',
  }" [shape=hexagon];
  "metadata: { category: 'integration-test' }" [shape=hexagon];
  "updatePayload = {
      name: 'Updated Test Assistant',
      description: 'This is an updated description.',
    }" [shape=hexagon];
  "gpt-threads.integration.test.ts" [shape=box];
  "unit" [shape=folder];
  "gpt-tests" [shape=folder];
  "gpt-api-thread.example.ts" [shape=box];
  "addMessage" [shape=diamond];
  "runAssistant" [shape=diamond];
  "runAssistantAndPoll" [shape=diamond];
  "getAllMessages" [shape=diamond];
  "extractAssistantResponse" [shape=diamond];
  "getAssistantResponse" [shape=diamond];
  "getRunResults" [shape=diamond];
  "getLastAssistantMessage" [shape=diamond];
  "queryAssistant" [shape=diamond];
  "addMessages" [shape=diamond];
  "getMessages" [shape=diamond];
  "initializeRun" [shape=diamond];
  "pollRunStatus" [shape=diamond];
  "addUserPrompt" [shape=diamond];
  "promptAssistant" [shape=diamond];
  "promptAssistantSimple" [shape=diamond];
  "openai.beta.threads.messages.create(threadId, { role, content })" [shape=hexagon];
  "openai.beta.threads.runs.create(threadId, {
      assistant_id: assistantId,
    })" [shape=hexagon];
  "openai.beta.threads.runs.createAndPoll(threadId, {
      assistant_id: assistantId,
      instructions,
    })" [shape=hexagon];
  "openai.beta.threads.messages.list(threadId, { limit, order })" [shape=hexagon];
  "openai.beta.threads.messages.list(threadId, { limit: 10, order: 'desc' })" [shape=hexagon];
  "openai.beta.threads.create({
      // it is possible to have mini instructions here too: instructions:""
      metadata: {
        purpose: 'Direct Query',
        created_by: 'system',
      },
    })" [shape=hexagon];
  "metadata: {
        purpose: 'Direct Query',
        created_by: 'system',
      }" [shape=hexagon];
  "openai.beta.threads.messages.create(threadId, { role: 'user', content: prompt })" [shape=hexagon];
  "openai.beta.threads.runs.createAndPoll(threadId, {
      assistant_id: assistantId,
    })" [shape=hexagon];
  "openai.beta.threads.messages.list(threadId, { limit: 1, order: 'desc' })" [shape=hexagon];
  "openai.beta.threads.messages.create(threadId, { role: msg.role, content: msg.content })" [shape=hexagon];
  "openai.beta.threads.messages.list(threadId, { limit, order })" [shape=hexagon];
  "openai.beta.threads.runs.create(threadId, { assistant_id: assistantId })" [shape=hexagon];
  "openai.beta.threads.messages.create(threadId, {
      role: 'user',
      content: prompt,
    })" [shape=hexagon];
  "gpt-assistant-with-functions.example.ts" [shape=box];
  "gpt-assistant.test.ts" [shape=box];
  "({
  getOpenAI: jest.fn(),
})" [shape=hexagon];
  "mockOpenAI = {
    beta: {
      assistants: {
        create: jest.fn(),
        retrieve: jest.fn(),
        update: jest.fn(),
        del: jest.fn(),
      },
    },
  }" [shape=hexagon];
  "beta: {
      assistants: {
        create: jest.fn(),
        retrieve: jest.fn(),
        update: jest.fn(),
        del: jest.fn(),
      },
    }" [shape=hexagon];
  "assistants: {
        create: jest.fn(),
        retrieve: jest.fn(),
        update: jest.fn(),
        del: jest.fn(),
      }" [shape=hexagon];
  "examplePayload: GptAssistantCreateRequest = {
    model: 'gpt-4o',
    instructions: 'You are a helpful assistant.',
    name: 'Test Assistant',
    description: 'This is a test assistant.',
    tools: [{ type: 'code_interpreter' }],
    metadata: { category: 'testing' },
    temperature: 0.7,
    top_p: 0.9,
    response_format: 'auto',
  }" [shape=hexagon];
  "[{ type: 'code_interpreter' }]" [shape=hexagon];
  "metadata: { category: 'testing' }" [shape=hexagon];
  "mockOpenAI.beta.assistants.create.mockResolvedValue({
      id: 'asst_123',
      model: examplePayload.model,
      instructions: examplePayload.instructions,
      name: examplePayload.name,
      description: examplePayload.description,
      tools: examplePayload.tools,
      metadata: examplePayload.metadata,
      temperature: examplePayload.temperature,
      top_p: examplePayload.top_p,
    })" [shape=hexagon];
  "mockOpenAI.beta.assistants.retrieve.mockResolvedValue({
      id: createdAssistantId,
      model: examplePayload.model,
      instructions: examplePayload.instructions,
      name: examplePayload.name,
      description: examplePayload.description,
      tools: examplePayload.tools,
      metadata: examplePayload.metadata,
      temperature: examplePayload.temperature,
      top_p: examplePayload.top_p,
    })" [shape=hexagon];
  "updatePayload = { name: 'Updated Assistant' }" [shape=hexagon];
  "mockOpenAI.beta.assistants.update.mockResolvedValue({
      ...examplePayload,
      id: createdAssistantId,
      name: updatePayload.name,
    })" [shape=hexagon];
  "mockOpenAI.beta.assistants.del.mockResolvedValue({
      id: createdAssistantId,
      object: 'assistant.deleted',
      deleted: true,
    })" [shape=hexagon];
  "gpt-crud.example.ts" [shape=box];
  "other-tests" [shape=folder];
  "assistant.queries.test.ts" [shape=box];
  "buildGetAssistantWithFiltersQuery({})" [shape=hexagon];
  "buildGetAssistantWithFiltersQuery({ type: 'chat' })" [shape=hexagon];
  "buildGetAssistantWithFiltersQuery({ tags: ['ai', 'assistant'] })" [shape=hexagon];
  "buildGetAssistantWithFiltersQuery({ type: 'chat', tags: ['ai', 'assistant'] })" [shape=hexagon];
  "gpt-api-model.helper.test.ts" [shape=box];
  "expect.objectContaining({
        estimatedInputTokens: inputTokens,
        requiredOutputTokens: outputTokens,
        intelligenceLevel: intelligence,
        suggestedModel: 'gpt-4o',
        availableResponseTokens: expect.any(Number),
        isFeasible: true,
        recommendations: [],
      })" [shape=hexagon];
  "expect.objectContaining({
        estimatedInputTokens: inputTokens,
        requiredOutputTokens: outputTokens,
        intelligenceLevel: intelligence,
        suggestedModel: 'gpt-4o',
        isFeasible: false,
        recommendations: expect.arrayContaining([expect.stringContaining('exceed the context window')]),
      })" [shape=hexagon];
  "expect.objectContaining({
          alias: 'gpt-4o',
        })" [shape=hexagon];
  "expect.objectContaining({
          alias: 'o1',
        })" [shape=hexagon];
  "expect.objectContaining({
        alias: 'gpt-4-turbo',
      })" [shape=hexagon];
  "expect.objectContaining({
          alias: expect.any(String),
          contextWindow: expect.any(Number),
          maxOutputTokens: expect.any(Number),
          description: expect.any(String),
          useCase: expect.any(String),
        })" [shape=hexagon];
  "expect.objectContaining({
        estimatedInputTokens: inputTokens,
        requiredOutputTokens: outputTokens,
        isFeasible: expect.any(Boolean),
        recommendations: expect.any(Array),
      })" [shape=hexagon];
  "service-tests" [shape=folder];
  "assistant-full.service.test.ts" [shape=box];
  "assistant.service.test.ts" [shape=box];
  "newAssistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'> = {
      name: 'Test Assistant',
      description: 'A test assistant',
      type: 'completion',
      instructions: 'Some instructions',
    }" [shape=hexagon];
  "updates = {
      name: 'Updated Assistant',
      description: 'Updated description',
    }" [shape=hexagon];
  "assistantService.updateAssistant('non-existent-id', { name: 'Updated Name' })" [shape=hexagon];
  "database.test.ts" [shape=box];
  "ruleData = {
        id: 'rule1',
        relationshipTypes: JSON.stringify(['related_to', 'part_of']),
        priorityTags: JSON.stringify(['important', 'urgent']),
      }" [shape=hexagon];
  "JSON.stringify({ query: 'test query' })" [shape=hexagon];
  "JSON.stringify({ result: 'test result' })" [shape=hexagon];
  "expect(JSON.parse(task.outputData)).toEqual({ result: 'test result' })" [shape=hexagon];
  "feedback.service.test.ts" [shape=box];
  "feedbackData: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'> = {
      targetId: 'task1',
      targetType: 'task',
      userId: 'user1',
      rating: 4,
      comments: 'Great performance!',
    }" [shape=hexagon];
  "feedbackData: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'> = {
      targetId: 'task2',
      targetType: 'task',
      userId: 'user2',
      rating: 3,
      comments: 'Good, but room for improvement.',
    }" [shape=hexagon];
  "updates = {
      rating: 5,
      comments: 'Outstanding work!',
    }" [shape=hexagon];
  "feedbackData: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'> = {
      targetId: 'task3',
      targetType: 'task',
      userId: 'user3',
      rating: 2,
      comments: 'Needs improvement.',
    }" [shape=hexagon];
  "feedbackService.addFeedback({
      targetId: 'memory1',
      targetType: 'memory',
      userId: 'user4',
      rating: 4,
      comments: 'Helpful memory!',
    })" [shape=hexagon];
  "feedbackService.addFeedback({
      targetId: 'memory1',
      targetType: 'memory',
      userId: 'user5',
      rating: 5,
      comments: 'Very insightful!',
    })" [shape=hexagon];
  "updates = { rating: 3, comments: 'Test update' }" [shape=hexagon];
  "focused-memory.service.test.ts" [shape=box];
  "memory-extra.service.test.ts" [shape=box];
  "[
        { id: '1', name: 'Tag1' },
        { id: '2', name: 'Tag2' },
      ]" [shape=hexagon];
  "[
        { id: '1', name: 'Tag1' },
        { id: '2', name: 'Tag2' },
      ]" [shape=hexagon];
  "[{ id: '1', name: 'Tag1' }]" [shape=hexagon];
  "[
        { id: '1', name: 'Tag1' },
        { id: '2', name: 'Tag2' },
        { name: 'Tag3', id: expect.any(String) },
      ]" [shape=hexagon];
  "[
        { id: '1', name: 'Tag1' },
        { id: '2', name: 'Tag2' },
        { name: 'Tag3', id: expect.any(String) },
      ]" [shape=hexagon];
  "[
        { id: '1', name: 'Tag1' },
        { id: '2', name: 'Tag2' },
        { name: 'Tag3', id: expect.any(String) },
      ]" [shape=hexagon];
  "[{ id: '1', name: 'Tag1' }]" [shape=hexagon];
  "memory-focus-rule.service.test.ts" [shape=box];
  "updates = {
      maxResults: 10,
      relationshipTypes: ['related_to', 'part_of'],
      priorityTags: ['tag1', 'tag2'],
    }" [shape=hexagon];
  "updates = {
      maxResults: 10,
      relationshipTypes: ['example_of'],
    }" [shape=hexagon];
  "memory.service.test.ts" [shape=box];
  "memoryData: Omit<Memory, 'id' | 'createdAt' | 'updatedAt'> = {
      type: 'knowledge',
      tags: [
        { id: '1', name: 'tag1' },
        { id: '2', name: 'tag2' },
      ],
      description: 'Test memory description',
      data: { key: 'value' },
    }" [shape=hexagon];
  "[
        { id: '1', name: 'tag1' },
        { id: '2', name: 'tag2' },
      ]" [shape=hexagon];
  "[
        { id: '1', name: 'tag1' },
        { id: '2', name: 'tag2' },
      ]" [shape=hexagon];
  "data: { key: 'value' }" [shape=hexagon];
  "JSON.stringify({ key: 'value' })" [shape=hexagon];
  "updates = {
      description: 'Updated description',
      data: { key: 'updated' },
      tags: [
        { id: '2', name: 'tag2' },
        { id: '3', name: 'tag3' },
      ],
    }" [shape=hexagon];
  "data: { key: 'updated' }" [shape=hexagon];
  "[
        { id: '2', name: 'tag2' },
        { id: '3', name: 'tag3' },
      ]" [shape=hexagon];
  "[
        { id: '2', name: 'tag2' },
        { id: '3', name: 'tag3' },
      ]" [shape=hexagon];
  "JSON.stringify({ key: 'updated' })" [shape=hexagon];
  "updates: Memory = {
      tags: [{ id: '1', name: 'tag1' }],
      id: '',
      type: 'knowledge',
      description: null,
      data: null,
      createdAt: null,
      updatedAt: null,
    }" [shape=hexagon];
  "[{ id: '1', name: 'tag1' }]" [shape=hexagon];
  "memoryService.updateMemory('non-existent-id', { description: 'Does not exist' })" [shape=hexagon];
  "owned-memory.service.test.ts" [shape=box];
  "relationship-graph.service.test.ts" [shape=box];
  "relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'> = {
      type: 'task',
      targetId: 'memory1',
      relationshipType: 'depends_on',
    }" [shape=hexagon];
  "expect(allRelationships[0]).toMatchObject({
      type: 'task',
      targetId: 'memory1',
      relationshipType: 'depends_on',
    })" [shape=hexagon];
  "relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'> = {
      type: 'assistant',
      targetId: 'task1',
      relationshipType: 'related_to',
    }" [shape=hexagon];
  "relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'> = {
      type: 'memory',
      targetId: 'assistant1',
      relationshipType: 'derived_from',
    }" [shape=hexagon];
  "relationshipGraphService.updateRelationship(relationshipId, {
      relationshipType: 'part_of',
    })" [shape=hexagon];
  "expect(updatedRelationship).toMatchObject({
      type: 'memory',
      targetId: 'assistant1',
      relationshipType: 'part_of',
    })" [shape=hexagon];
  "relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'> = {
      type: 'task',
      targetId: 'memory2',
      relationshipType: 'blocks',
    }" [shape=hexagon];
  "relationshipGraphService.updateRelationship('nonexistent-id', {
        relationshipType: 'related_to',
      })" [shape=hexagon];
  "tag-extra.service.test.ts" [shape=box];
  "expect(tags[0]).toMatchObject({ id: 'tag1', name: 'responsive' })" [shape=hexagon];
  "expect(tags[0]).toMatchObject({ id: 'tag2', name: 'scalable' })" [shape=hexagon];
  "expect(assistantTags[0]).toMatchObject({ id: 'tag2', name: 'scalable' })" [shape=hexagon];
  "expect(taskTags[0]).toMatchObject({ id: 'tag2', name: 'scalable' })" [shape=hexagon];
  "tag.service.test.ts" [shape=box];
  "tagData: Omit<Tag, 'id'> = {
      name: 'Test Tag',
    }" [shape=hexagon];
  "tagService.updateTag(tagId, { name: 'Updated Tag Name' })" [shape=hexagon];
  "task.service.test.ts" [shape=box];
  "taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'> = {
      description: 'Test Task',
      assignedAssistant: 'assistant1',
      status: 'pending',
      inputData: { key: 'value' },
      outputData: undefined,
    }" [shape=hexagon];
  "inputData: { key: 'value' }" [shape=hexagon];
  "expect(task?.inputData).toEqual({ key: 'value' })" [shape=hexagon];
  "taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'> = {
      description: 'Update Test Task',
      assignedAssistant: 'assistant2',
      status: 'pending',
    }" [shape=hexagon];
  "updates: Task = {
      status: 'in_progress',
      outputData: { result: 'success' },
      id: '',
      description: '',
      assignedAssistant: '',
      createdAt: new Date(),
      updatedAt: new Date(),
    }" [shape=hexagon];
  "outputData: { result: 'success' }" [shape=hexagon];
  "expect(updatedTask?.outputData).toEqual({ result: 'success' })" [shape=hexagon];
  "taskData: Omit<Task, 'id' | 'createdAt' | 'updatedAt'> = {
      description: 'Delete Test Task',
      assignedAssistant: 'assistant3',
      status: 'pending',
    }" [shape=hexagon];
  "taskService.addTask({
      description: 'Pending Task',
      assignedAssistant: 'assistant4',
      status: 'pending',
    })" [shape=hexagon];
  "taskService.addTask({
      description: 'Completed Task',
      assignedAssistant: 'assistant5',
      status: 'completed',
    })" [shape=hexagon];
  "taskService.addTask({
      description: 'Task for Assistant 6',
      assignedAssistant: 'assistant6',
      status: 'pending',
    })" [shape=hexagon];
  "taskService.addTask({
      description: 'Task for Assistant 7',
      assignedAssistant: 'assistant7',
      status: 'pending',
    })" [shape=hexagon];
  "updates: Task = {
      status: 'completed',
      id: '',
      description: '',
      assignedAssistant: '',
      createdAt: new Date(),
      updatedAt: new Date(),
    }" [shape=hexagon];
  "test-db-insert.helper.ts" [shape=box];
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" [shape=hexagon];
  "insertTags" [shape=ellipse];
  "insertFullAssistantSetup" [shape=ellipse];
  "insertAssistant" [shape=ellipse];
  "insertMemoryFocusRule" [shape=ellipse];
  "insertFocusedMemory" [shape=ellipse];
  "insertMemories" [shape=ellipse];
  "insertMemory" [shape=ellipse];
  "insertMemoryFocusRules" [shape=ellipse];
  "test-db-return.helper.ts" [shape=box];
  "[
  {
    assistant_id: '1',
    assistant_name: 'Test Assistant',
    assistant_description: 'A test assistant',
    assistant_type: 'chat',
    assistant_instructions: null,
    avg_rating: 5,
    total_feedback: 2,
    assistant_createdAt: '2025-01-01T10:00:00Z',
    assistant_updatedAt: '2025-01-02T10:00:00Z',
    assistant_tag_id: 'tag1',
    assistant_tag_name: 'Test Tag 1',
    focus_rule_id: 'focus1',
    focus_rule_maxResults: 10,
    focus_rule_relationshipTypes: '["related_to"]',
    focus_rule_priorityTags: '["priority1"]',
    focus_rule_createdAt: '2025-01-01T10:30:00Z',
    focus_rule_updatedAt: '2025-01-02T10:30:00Z',
    memory_id: 'memory1',
    memory_type: 'knowledge',
    memory_description: 'Test Memory Description',
    memory_data: '{"key": "value"}',
    memory_createdAt: '2025-01-01T11:00:00Z',
    memory_updatedAt: '2025-01-02T11:00:00Z',
    memory_tag_id: 'memory-tag1',
    memory_tag_name: 'Memory Tag 1',
  },
  {
    assistant_id: '1',
    assistant_name: 'Test Assistant',
    assistant_description: 'A test assistant',
    assistant_type: 'chat',
    assistant_instructions: null,
    avg_rating: 5,
    total_feedback: 2,
    assistant_createdAt: '2025-01-01T10:00:00Z',
    assistant_updatedAt: '2025-01-02T10:00:00Z',
    assistant_tag_id: 'tag2',
    assistant_tag_name: 'Test Tag 2',
    focus_rule_id: 'focus1',
    focus_rule_maxResults: 10,
    focus_rule_relationshipTypes: '["related_to"]',
    focus_rule_priorityTags: '["priority1"]',
    focus_rule_createdAt: '2025-01-01T10:30:00Z',
    focus_rule_updatedAt: '2025-01-02T10:30:00Z',
    memory_id: 'memory1',
    memory_type: 'knowledge',
    memory_description: 'Test Memory Description',
    memory_data: '{"key": "value"}',
    memory_createdAt: '2025-01-01T11:00:00Z',
    memory_updatedAt: '2025-01-02T11:00:00Z',
    memory_tag_id: 'memory-tag2',
    memory_tag_name: 'Memory Tag 2',
  },
]" [shape=hexagon];
  "[
  {
    assistant_id: '1',
    assistant_name: 'Test Assistant',
    assistant_description: 'A test assistant',
    assistant_type: 'chat',
    assistant_instructions: null,
    avg_rating: 5,
    total_feedback: 2,
    assistant_createdAt: '2025-01-01T10:00:00Z',
    assistant_updatedAt: '2025-01-02T10:00:00Z',
    assistant_tag_id: 'tag1',
    assistant_tag_name: 'Test Tag 1',
    focus_rule_id: 'focus1',
    focus_rule_maxResults: 10,
    focus_rule_relationshipTypes: '["related_to"]',
    focus_rule_priorityTags: '["priority1"]',
    focus_rule_createdAt: '2025-01-01T10:30:00Z',
    focus_rule_updatedAt: '2025-01-02T10:30:00Z',
    memory_id: 'memory1',
    memory_type: 'knowledge',
    memory_description: 'Test Memory Description',
    memory_data: '{"key": "value"}',
    memory_createdAt: '2025-01-01T11:00:00Z',
    memory_updatedAt: '2025-01-02T11:00:00Z',
    memory_tag_id: 'memory-tag1',
    memory_tag_name: 'Memory Tag 1',
  },
  {
    assistant_id: '1',
    assistant_name: 'Test Assistant',
    assistant_description: 'A test assistant',
    assistant_type: 'chat',
    assistant_instructions: null,
    avg_rating: 5,
    total_feedback: 2,
    assistant_createdAt: '2025-01-01T10:00:00Z',
    assistant_updatedAt: '2025-01-02T10:00:00Z',
    assistant_tag_id: 'tag2',
    assistant_tag_name: 'Test Tag 2',
    focus_rule_id: 'focus1',
    focus_rule_maxResults: 10,
    focus_rule_relationshipTypes: '["related_to"]',
    focus_rule_priorityTags: '["priority1"]',
    focus_rule_createdAt: '2025-01-01T10:30:00Z',
    focus_rule_updatedAt: '2025-01-02T10:30:00Z',
    memory_id: 'memory1',
    memory_type: 'knowledge',
    memory_description: 'Test Memory Description',
    memory_data: '{"key": "value"}',
    memory_createdAt: '2025-01-01T11:00:00Z',
    memory_updatedAt: '2025-01-02T11:00:00Z',
    memory_tag_id: 'memory-tag2',
    memory_tag_name: 'Memory Tag 2',
  },
]" [shape=hexagon];
  "test-db.helper.ts" [shape=box];
  "TestDbHelper" [shape=ellipse];
  "test-object.helper.ts" [shape=box];
  "testFullAssistantObject: AssistantWithDetails = {
  id: '1',
  name: 'Test Assistant',
  description: 'A test assistant',
  type: 'chat',
  instructions: undefined,
  createdAt: new Date('2025-01-01T10:00:00Z'),
  updatedAt: new Date('2025-01-02T10:00:00Z'),
  assistantTags: [
    { id: 'tag1', name: 'Test Tag 1' },
    { id: 'tag2', name: 'Test Tag 2' },
  ],
  focusedMemories: [
    {
      id: 'memory1',
      type: 'knowledge',
      description: 'Test Memory Description',
      data: { key: 'value' },
      createdAt: new Date('2025-01-01T11:00:00Z'),
      updatedAt: new Date('2025-01-02T11:00:00Z'),
      tags: [
        { id: 'memory-tag1', name: 'Memory Tag 1' },
        { id: 'memory-tag2', name: 'Memory Tag 2' },
      ],
    },
  ],
  memoryFocusRule: {
    id: 'focus1',
    assistantId: '1',
    maxResults: 10,
    relationshipTypes: ['related_to'],
    priorityTags: ['priority1'],
    createdAt: new Date('2025-01-01T10:30:00Z'),
    updatedAt: new Date('2025-01-02T10:30:00Z'),
  },
  feedbackSummary: {
    avgRating: 5,
    totalFeedback: 2,
  },
}" [shape=hexagon];
  "[
    { id: 'tag1', name: 'Test Tag 1' },
    { id: 'tag2', name: 'Test Tag 2' },
  ]" [shape=hexagon];
  "[
    { id: 'tag1', name: 'Test Tag 1' },
    { id: 'tag2', name: 'Test Tag 2' },
  ]" [shape=hexagon];
  "[
    {
      id: 'memory1',
      type: 'knowledge',
      description: 'Test Memory Description',
      data: { key: 'value' },
      createdAt: new Date('2025-01-01T11:00:00Z'),
      updatedAt: new Date('2025-01-02T11:00:00Z'),
      tags: [
        { id: 'memory-tag1', name: 'Memory Tag 1' },
        { id: 'memory-tag2', name: 'Memory Tag 2' },
      ],
    },
  ]" [shape=hexagon];
  "data: { key: 'value' }" [shape=hexagon];
  "[
        { id: 'memory-tag1', name: 'Memory Tag 1' },
        { id: 'memory-tag2', name: 'Memory Tag 2' },
      ]" [shape=hexagon];
  "[
        { id: 'memory-tag1', name: 'Memory Tag 1' },
        { id: 'memory-tag2', name: 'Memory Tag 2' },
      ]" [shape=hexagon];
  "memoryFocusRule: {
    id: 'focus1',
    assistantId: '1',
    maxResults: 10,
    relationshipTypes: ['related_to'],
    priorityTags: ['priority1'],
    createdAt: new Date('2025-01-01T10:30:00Z'),
    updatedAt: new Date('2025-01-02T10:30:00Z'),
  }" [shape=hexagon];
  "feedbackSummary: {
    avgRating: 5,
    totalFeedback: 2,
  }" [shape=hexagon];
  "transformer-tests" [shape=folder];
  "assistant-full.transformer.test.ts" [shape=box];
  "({
      ...row,
      assistant_tag_id: null,
      assistant_tag_name: null,
    })" [shape=hexagon];
  "({
      ...row,
      memory_id: null,
      memory_type: null,
      memory_description: null,
      memory_data: null,
      memory_createdAt: null,
      memory_updatedAt: null,
      memory_tag_id: null,
      memory_tag_name: null,
    })" [shape=hexagon];
  "({
      ...row,
      memory_id: index === 0 ? '1' : null,
      memory_type: index === 0 ? 'knowledge' : null,
      memory_description: index === 0 ? 'Partial Memory' : null,
      memory_data: index === 0 ? '{"key":"value"}' : null,
      memory_createdAt: index === 0 ? new Date().toISOString() : null,
      memory_updatedAt: index === 0 ? new Date().toISOString() : null,
    })" [shape=hexagon];
  "expect(result.focusedMemories[0]).toMatchObject({
      id: '1',
      type: 'knowledge',
      description: 'Partial Memory',
      data: { key: 'value' },
    })" [shape=hexagon];
  "data: { key: 'value' }" [shape=hexagon];
  "[
        {
          assistant_id: '1',
          assistant_name: 'Test Assistant',
          assistant_description: 'Test Description',
          assistant_type: 'completion',
          assistant_instructions: null,
          avg_rating: 0,
          total_feedback: 0,
          assistant_createdAt: new Date().toISOString(),
          assistant_updatedAt: new Date().toISOString(),
          assistant_tag_id: null, // No tags
          assistant_tag_name: null, // No tags
          focus_rule_id: null,
          focus_rule_maxResults: null,
          focus_rule_relationshipTypes: null,
          focus_rule_priorityTags: null,
          focus_rule_createdAt: null,
          focus_rule_updatedAt: null,
          memory_id: null,
          memory_type: null,
          memory_description: null,
          memory_data: null,
          memory_createdAt: null,
          memory_updatedAt: null,
          memory_tag_id: null,
          memory_tag_name: null,
        },
      ]" [shape=hexagon];
  "({
      ...row,
      focus_rule_id: null,
      focus_rule_maxResults: null,
      focus_rule_relationshipTypes: null,
      focus_rule_priorityTags: null,
      focus_rule_createdAt: null,
      focus_rule_updatedAt: null,
    })" [shape=hexagon];
  "assistant.transformer.test.ts" [shape=box];
  "mockAssistantRow: AssistantRow = {
  id: 'assistant-1',
  name: 'Test Assistant',
  description: 'A description for the assistant',
  type: 'completion',
  instructions: null,
  createdAt: '2023-01-01T00:00:00.000Z',
  updatedAt: '2023-01-02T00:00:00.000Z',
}" [shape=hexagon];
  "[
  {
    id: 'memory-1',
    type: 'knowledge',
    description: 'Memory description',
    data: JSON.stringify({ key: 'value' }),
    createdAt: '2023-01-01T00:00:00.000Z',
    updatedAt: '2023-01-02T00:00:00.000Z',
  },
]" [shape=hexagon];
  "JSON.stringify({ key: 'value' })" [shape=hexagon];
  "mockMemoryTags = {
  'memory-1': [
    { id: 'tag-1', name: 'Tag 1' },
    { id: 'tag-2', name: 'Tag 2' },
  ],
}" [shape=hexagon];
  "[
    { id: 'tag-1', name: 'Tag 1' },
    { id: 'tag-2', name: 'Tag 2' },
  ]" [shape=hexagon];
  "[
    { id: 'tag-1', name: 'Tag 1' },
    { id: 'tag-2', name: 'Tag 2' },
  ]" [shape=hexagon];
  "[
  { id: 'tag-3', name: 'Assistant Tag 1' },
  { id: 'tag-4', name: 'Assistant Tag 2' },
]" [shape=hexagon];
  "[
  { id: 'tag-3', name: 'Assistant Tag 1' },
  { id: 'tag-4', name: 'Assistant Tag 2' },
]" [shape=hexagon];
  "mockMemoryFocusRuleRow: MemoryFocusRuleRow = {
  id: 'focus-rule-1',
  assistant_id: 'assistant-1',
  maxResults: 5,
  relationshipTypes: JSON.stringify(['related_to']),
  priorityTags: JSON.stringify(['important']),
  createdAt: '2023-01-01T00:00:00.000Z',
  updatedAt: '2023-01-02T00:00:00.000Z',
}" [shape=hexagon];
  "[
      { id: 'tag-3', name: 'Assistant Tag 1' },
      { id: 'tag-4', name: 'Assistant Tag 2' },
    ]" [shape=hexagon];
  "[
      { id: 'tag-3', name: 'Assistant Tag 1' },
      { id: 'tag-4', name: 'Assistant Tag 2' },
    ]" [shape=hexagon];
  "expect(result.focusedMemories[0]).toMatchObject({
      id: 'memory-1',
      type: 'knowledge',
      description: 'Memory description',
      tags: [
        { id: 'tag-1', name: 'Tag 1' },
        { id: 'tag-2', name: 'Tag 2' },
      ],
    })" [shape=hexagon];
  "[
        { id: 'tag-1', name: 'Tag 1' },
        { id: 'tag-2', name: 'Tag 2' },
      ]" [shape=hexagon];
  "[
        { id: 'tag-1', name: 'Tag 1' },
        { id: 'tag-2', name: 'Tag 2' },
      ]" [shape=hexagon];
  "expect(result.memoryFocusRule).toMatchObject({
      id: 'focus-rule-1',
      assistantId: 'assistant-1',
      maxResults: 5,
      relationshipTypes: ['related_to'],
      priorityTags: ['important'],
    })" [shape=hexagon];
  "transformAssistantWithDetails(mockAssistantRow, [], {}, mockAssistantTags, mockMemoryFocusRuleRow)" [shape=hexagon];
  "memory-focus-rule.transformer.test.ts" [shape=box];
  "row: MemoryFocusRuleRow = {
      id: 'rule-1',
      assistant_id: 'assistant-1',
      maxResults: 5,
      relationshipTypes: JSON.stringify(['related_to', 'example_of']),
      priorityTags: JSON.stringify(['tag1', 'tag2']),
      createdAt: new Date('2025-01-01T12:00:00Z').toISOString(),
      updatedAt: new Date('2025-01-02T12:00:00Z').toISOString(),
    }" [shape=hexagon];
  "expected: MemoryFocusRule = {
      id: 'rule-1',
      assistantId: 'assistant-1',
      maxResults: 5,
      relationshipTypes: ['related_to', 'example_of'],
      priorityTags: ['tag1', 'tag2'],
      createdAt: new Date('2025-01-01T12:00:00Z'),
      updatedAt: new Date('2025-01-02T12:00:00Z'),
    }" [shape=hexagon];
  "row: MemoryFocusRuleRow = {
      id: 'rule-2',
      assistant_id: 'assistant-2',
      maxResults: 10,
      relationshipTypes: null,
      priorityTags: null,
      createdAt: new Date('2025-01-03T12:00:00Z').toISOString(),
      updatedAt: new Date('2025-01-04T12:00:00Z').toISOString(),
    }" [shape=hexagon];
  "expected: MemoryFocusRule = {
      id: 'rule-2',
      assistantId: 'assistant-2',
      maxResults: 10,
      relationshipTypes: [],
      priorityTags: [],
      createdAt: new Date('2025-01-03T12:00:00Z'),
      updatedAt: new Date('2025-01-04T12:00:00Z'),
    }" [shape=hexagon];
  "memory.transformer.test.ts" [shape=box];
  "[
    { id: 'tag1', name: 'Tag 1' },
    { id: 'tag2', name: 'Tag 2' },
  ]" [shape=hexagon];
  "[
    { id: 'tag1', name: 'Tag 1' },
    { id: 'tag2', name: 'Tag 2' },
  ]" [shape=hexagon];
  "row: MemoryRow = {
      id: 'memory1',
      type: 'instruction',
      description: 'Test description',
      data: '{"key":"value"}',
      createdAt: '2025-01-01T00:00:00Z',
      updatedAt: '2025-01-02T00:00:00Z',
    }" [shape=hexagon];
  "expect(result).toEqual({
      id: 'memory1',
      type: 'instruction',
      tags,
      description: 'Test description',
      data: { key: 'value' },
      createdAt: new Date('2025-01-01T00:00:00Z'),
      updatedAt: new Date('2025-01-02T00:00:00Z'),
    })" [shape=hexagon];
  "data: { key: 'value' }" [shape=hexagon];
  "row: MemoryRow = {
      id: 'memory2',
      type: 'session',
      description: null,
      data: null,
      createdAt: '2025-01-03T00:00:00Z',
      updatedAt: '2025-01-04T00:00:00Z',
    }" [shape=hexagon];
  "expect(result).toEqual({
      id: 'memory2',
      type: 'session',
      tags,
      description: null,
      data: null,
      createdAt: new Date('2025-01-03T00:00:00Z'),
      updatedAt: new Date('2025-01-04T00:00:00Z'),
    })" [shape=hexagon];
  "row: MemoryRow = {
      id: 'memory3',
      type: 'meta',
      description: 'Invalid JSON test',
      data: '{invalidJson}',
      createdAt: '2025-01-05T00:00:00Z',
      updatedAt: '2025-01-06T00:00:00Z',
    }" [shape=hexagon];
  "transformers" [shape=folder];
  "assistant-full.transformer.ts" [shape=box];
  "transformFullAssistantResult" [shape=diamond];
  "feedbackSummary: FeedbackSummary = {
    avgRating: firstRow.avg_rating || 0,
    totalFeedback: firstRow.total_feedback || 0,
  }" [shape=hexagon];
  "assistant: AssistantWithDetails = {
    id: firstRow.assistant_id,
    name: firstRow.assistant_name,
    description: firstRow.assistant_description,
    type: firstRow.assistant_type,
    assistantTags: [], // Populated below
    instructions: firstRow.assistant_instructions || undefined,
    createdAt: new Date(firstRow.assistant_createdAt),
    updatedAt: new Date(firstRow.assistant_updatedAt),
    focusedMemories: [],
    memoryFocusRule: undefined,
    feedbackSummary,
  }" [shape=hexagon];
  "assistantTagsMap.set(row.assistant_tag_id, {
          id: row.assistant_tag_id,
          name: row.assistant_tag_name,
        })" [shape=hexagon];
  "focusedMemoriesMap.set(row.memory_id, { row, tags: [] })" [shape=hexagon];
  "focusedMemoriesMap.get(row.memory_id)?.tags.push({
          id: row.memory_tag_id,
          name: row.memory_tag_name,
        })" [shape=hexagon];
  "transformMemoryRow(
        {
          id: row.memory_id,
          type: row.memory_type as Memory['type'], // Cast safely after null-check
          description: row.memory_description || null,
          data: row.memory_data,
          createdAt: row.memory_createdAt!,
          updatedAt: row.memory_updatedAt!,
        },
        tags
      )" [shape=hexagon];
  "assistant.memoryFocusRule = {
      id: firstRow.focus_rule_id,
      assistantId: firstRow.assistant_id,
      maxResults: firstRow.focus_rule_maxResults || 0,
      relationshipTypes: JSON.parse(firstRow.focus_rule_relationshipTypes || '[]'),
      priorityTags: JSON.parse(firstRow.focus_rule_priorityTags || '[]'),
      createdAt: firstRow.focus_rule_createdAt ? new Date(firstRow.focus_rule_createdAt) : new Date(),
      updatedAt: firstRow.focus_rule_updatedAt ? new Date(firstRow.focus_rule_updatedAt) : new Date(),
    }" [shape=hexagon];
  "assistant.transformer.ts" [shape=box];
  "transformAssistantRow" [shape=diamond];
  "transformAssistantWithDetails" [shape=diamond];
  "return {
    id: row.id,
    name: row.name,
    description: row.description,
    type: row.type,
    instructions: row.instructions || undefined,
    createdAt: new Date(row.createdAt),
    updatedAt: new Date(row.updatedAt),
  };" [shape=hexagon];
  "feedbackSummary: FeedbackSummary = {
    avgRating: feedbackSummaryRows?.avg_rating || 0,
    totalFeedback: feedbackSummaryRows?.total_feedback || 0,
  }" [shape=hexagon];
  "return {
    ...assistant,
    focusedMemories,
    memoryFocusRule,
    assistantTags: assistantTagsTransformed,
    feedbackSummary,
  };" [shape=hexagon];
  "memory-focus-rule.transformer.ts" [shape=box];
  "transformMemoryFocusRuleRow" [shape=diamond];
  "return {
    id: row.id,
    assistantId: row.assistant_id,
    maxResults: row.maxResults,
    relationshipTypes: row.relationshipTypes ? JSON.parse(row.relationshipTypes) : [], // Default to an empty array
    priorityTags: row.priorityTags ? JSON.parse(row.priorityTags) : [], // Default to an empty array
    createdAt: new Date(row.createdAt), // Ensure a valid Date is created
    updatedAt: new Date(row.updatedAt), // Ensure a valid Date is created
  };" [shape=hexagon];
  "memory.transformer.ts" [shape=box];
  "transformMemoryRow" [shape=diamond];
  "return {
    id: row.id,
    type: row.type,
    tags, // Relational tags
    description: row.description || null, // Use null instead of undefined
    data: row.data ? JSON.parse(row.data) : null, // Use null instead of undefined
    createdAt: new Date(row.createdAt), // Ensure a valid Date is created
    updatedAt: new Date(row.updatedAt), // Ensure a valid Date is created
  };" [shape=hexagon];
  "tag.transformer.ts" [shape=box];
  "transformTagRow" [shape=diamond];
  "return {
    id: row.id,
    name: row.name,
  };" [shape=hexagon];
  "controllers" -> "assistant.controller.ts";
  "database" -> "database.ts";
  "database" -> "init.ts";
  "models" -> "assistant.model.ts";
  "models" -> "feedback.model.ts";
  "models" -> "focused-memory.model.ts";
  "models" -> "memory.model.ts";
  "models" -> "promotion-criteria.model.ts";
  "models" -> "relationship.model.ts";
  "models" -> "service-models";
  "service-models" -> "connector.service.model.ts";
  "models" -> "tag.model.ts";
  "models" -> "task.model.ts";
  "queries" -> "assistant.queries.ts";
  "routes" -> "assistant.routes.ts";
  "services" -> "assistant-full.service.ts";
  "fullAssistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch full assistant details using individual queries.
   */
  async getFullAssistantWithDetails(id: string): Promise<AssistantWithDetails | null> {
    try {
      // Fetch assistant details
      const assistantRow = this.db
        .prepare(
          `
      SELECT * 
      FROM assistants 
      WHERE id = ?
    `
        )
        .get(id) as AssistantRow | undefined;

      if (!assistantRow) return null;

      // Fetch assistant tags
      const assistantTagRows = this.db
        .prepare(
          `
      SELECT t.* 
      FROM assistant_tags at
      JOIN tags t ON at.tag_id = t.id
      WHERE at.assistant_id = ?
    `
        )
        .all(id) as TagRow[];

      // Fetch memory focus rule
      const memoryFocusRuleRow = this.db
        .prepare(
          `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
        )
        .get(id) as MemoryFocusRuleRow | undefined;

      // Fetch related focused memories if a focus rule exists
      const memoryRows = memoryFocusRuleRow
        ? (this.db
            .prepare(
              `
          SELECT m.*, t.id AS tag_id, t.name AS tag_name
          FROM focused_memories fm
          JOIN memories m ON fm.memory_id = m.id
          LEFT JOIN memory_tags mt ON m.id = mt.memory_id
          LEFT JOIN tags t ON mt.tag_id = t.id
          WHERE fm.memory_focus_id = ?
        `
            )
            .all(memoryFocusRuleRow.id) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[])
        : [];

      // Group tags by memory ID
      const memoryTags: Record<string, Tag[]> = {};
      memoryRows.forEach((row) => {
        if (!memoryTags[row.id]) {
          memoryTags[row.id] = [];
        }
        if (row.tag_id && row.tag_name) {
          memoryTags[row.id].push({ id: row.tag_id, name: row.tag_name });
        }
      });

      // Fetch feedback summary for the assistant
      const feedbackSummaryRow = this.db
        .prepare(
          `
      SELECT 
        COALESCE(AVG(f.rating), 0) AS avgRating, 
        COALESCE(COUNT(f.id), 0) AS totalFeedback
      FROM feedback f
      JOIN tasks t ON f.target_id = t.id AND f.target_type = 'task'
      WHERE t.assignedAssistant = ?
    `
        )
        .get(id) as FeedbackSummaryRow;

      // Transform and return the AssistantWithDetails object
      return transformAssistantWithDetails(assistantRow, memoryRows, memoryTags, assistantTagRows, memoryFocusRuleRow, feedbackSummaryRow);
    } catch (error) {
      console.error('Error fetching full assistant details:', error);
      throw new Error('Failed to fetch assistant details.');
    }
  },

  /**
   * Fetch full assistant details using an efficient single query.
   */
  async getFullAssistantWithDetailsEfficient(id: string): Promise<AssistantWithDetails | null> {
    try {
      const rows = this.db.prepare(GET_FULL_ASSISTANT_WITH_DETAILS).all(id) as FullAssistantRows[];
      if (rows.length === 0) return null;

      return transformFullAssistantResult(rows);
    } catch (error) {
      console.error('Error transforming full assistant details:', error);
      throw new Error('Failed to fetch assistant details efficiently.');
    }
  },
}" -> "setDb";
  "fullAssistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch full assistant details using individual queries.
   */
  async getFullAssistantWithDetails(id: string): Promise<AssistantWithDetails | null> {
    try {
      // Fetch assistant details
      const assistantRow = this.db
        .prepare(
          `
      SELECT * 
      FROM assistants 
      WHERE id = ?
    `
        )
        .get(id) as AssistantRow | undefined;

      if (!assistantRow) return null;

      // Fetch assistant tags
      const assistantTagRows = this.db
        .prepare(
          `
      SELECT t.* 
      FROM assistant_tags at
      JOIN tags t ON at.tag_id = t.id
      WHERE at.assistant_id = ?
    `
        )
        .all(id) as TagRow[];

      // Fetch memory focus rule
      const memoryFocusRuleRow = this.db
        .prepare(
          `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
        )
        .get(id) as MemoryFocusRuleRow | undefined;

      // Fetch related focused memories if a focus rule exists
      const memoryRows = memoryFocusRuleRow
        ? (this.db
            .prepare(
              `
          SELECT m.*, t.id AS tag_id, t.name AS tag_name
          FROM focused_memories fm
          JOIN memories m ON fm.memory_id = m.id
          LEFT JOIN memory_tags mt ON m.id = mt.memory_id
          LEFT JOIN tags t ON mt.tag_id = t.id
          WHERE fm.memory_focus_id = ?
        `
            )
            .all(memoryFocusRuleRow.id) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[])
        : [];

      // Group tags by memory ID
      const memoryTags: Record<string, Tag[]> = {};
      memoryRows.forEach((row) => {
        if (!memoryTags[row.id]) {
          memoryTags[row.id] = [];
        }
        if (row.tag_id && row.tag_name) {
          memoryTags[row.id].push({ id: row.tag_id, name: row.tag_name });
        }
      });

      // Fetch feedback summary for the assistant
      const feedbackSummaryRow = this.db
        .prepare(
          `
      SELECT 
        COALESCE(AVG(f.rating), 0) AS avgRating, 
        COALESCE(COUNT(f.id), 0) AS totalFeedback
      FROM feedback f
      JOIN tasks t ON f.target_id = t.id AND f.target_type = 'task'
      WHERE t.assignedAssistant = ?
    `
        )
        .get(id) as FeedbackSummaryRow;

      // Transform and return the AssistantWithDetails object
      return transformAssistantWithDetails(assistantRow, memoryRows, memoryTags, assistantTagRows, memoryFocusRuleRow, feedbackSummaryRow);
    } catch (error) {
      console.error('Error fetching full assistant details:', error);
      throw new Error('Failed to fetch assistant details.');
    }
  },

  /**
   * Fetch full assistant details using an efficient single query.
   */
  async getFullAssistantWithDetailsEfficient(id: string): Promise<AssistantWithDetails | null> {
    try {
      const rows = this.db.prepare(GET_FULL_ASSISTANT_WITH_DETAILS).all(id) as FullAssistantRows[];
      if (rows.length === 0) return null;

      return transformFullAssistantResult(rows);
    } catch (error) {
      console.error('Error transforming full assistant details:', error);
      throw new Error('Failed to fetch assistant details efficiently.');
    }
  },
}" -> "getFullAssistantWithDetails";
  "fullAssistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch full assistant details using individual queries.
   */
  async getFullAssistantWithDetails(id: string): Promise<AssistantWithDetails | null> {
    try {
      // Fetch assistant details
      const assistantRow = this.db
        .prepare(
          `
      SELECT * 
      FROM assistants 
      WHERE id = ?
    `
        )
        .get(id) as AssistantRow | undefined;

      if (!assistantRow) return null;

      // Fetch assistant tags
      const assistantTagRows = this.db
        .prepare(
          `
      SELECT t.* 
      FROM assistant_tags at
      JOIN tags t ON at.tag_id = t.id
      WHERE at.assistant_id = ?
    `
        )
        .all(id) as TagRow[];

      // Fetch memory focus rule
      const memoryFocusRuleRow = this.db
        .prepare(
          `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
        )
        .get(id) as MemoryFocusRuleRow | undefined;

      // Fetch related focused memories if a focus rule exists
      const memoryRows = memoryFocusRuleRow
        ? (this.db
            .prepare(
              `
          SELECT m.*, t.id AS tag_id, t.name AS tag_name
          FROM focused_memories fm
          JOIN memories m ON fm.memory_id = m.id
          LEFT JOIN memory_tags mt ON m.id = mt.memory_id
          LEFT JOIN tags t ON mt.tag_id = t.id
          WHERE fm.memory_focus_id = ?
        `
            )
            .all(memoryFocusRuleRow.id) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[])
        : [];

      // Group tags by memory ID
      const memoryTags: Record<string, Tag[]> = {};
      memoryRows.forEach((row) => {
        if (!memoryTags[row.id]) {
          memoryTags[row.id] = [];
        }
        if (row.tag_id && row.tag_name) {
          memoryTags[row.id].push({ id: row.tag_id, name: row.tag_name });
        }
      });

      // Fetch feedback summary for the assistant
      const feedbackSummaryRow = this.db
        .prepare(
          `
      SELECT 
        COALESCE(AVG(f.rating), 0) AS avgRating, 
        COALESCE(COUNT(f.id), 0) AS totalFeedback
      FROM feedback f
      JOIN tasks t ON f.target_id = t.id AND f.target_type = 'task'
      WHERE t.assignedAssistant = ?
    `
        )
        .get(id) as FeedbackSummaryRow;

      // Transform and return the AssistantWithDetails object
      return transformAssistantWithDetails(assistantRow, memoryRows, memoryTags, assistantTagRows, memoryFocusRuleRow, feedbackSummaryRow);
    } catch (error) {
      console.error('Error fetching full assistant details:', error);
      throw new Error('Failed to fetch assistant details.');
    }
  },

  /**
   * Fetch full assistant details using an efficient single query.
   */
  async getFullAssistantWithDetailsEfficient(id: string): Promise<AssistantWithDetails | null> {
    try {
      const rows = this.db.prepare(GET_FULL_ASSISTANT_WITH_DETAILS).all(id) as FullAssistantRows[];
      if (rows.length === 0) return null;

      return transformFullAssistantResult(rows);
    } catch (error) {
      console.error('Error transforming full assistant details:', error);
      throw new Error('Failed to fetch assistant details efficiently.');
    }
  },
}" -> "getFullAssistantWithDetailsEfficient";
  "services" -> "assistant.service.ts";
  "assistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  // Fetch all assistants
  getAllAssistants(): AssistantRow[] {
    const stmt = this.db.prepare('SELECT * FROM assistants');
    return stmt.all() as AssistantRow[];
  },

  // Fetch a single assistant by ID
  getAssistantById(id: string): AssistantRow | null {
    const stmt = this.db.prepare('SELECT * FROM assistants WHERE id = ?');
    const result = stmt.get(id);
    return result ? (result as AssistantRow) : null;
  },

  // Add a new assistant
  async addAssistant(assistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the assistant
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO assistants (id, name, description, type, instructions, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, assistant.name, assistant.description, assistant.type, assistant.instructions || null, createdAt, updatedAt);

    return id;
  },

  // Update an existing assistant
  async updateAssistant(id: string, updates: Partial<Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingAssistant = this.db.prepare('SELECT * FROM assistants WHERE id = ?').get(id) as AssistantRow | undefined;

    if (!existingAssistant) {
      throw new Error(`Assistant with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE assistants
      SET
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        type = COALESCE(?, type),
        instructions = COALESCE(?, instructions),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.name || null,
      updates.description || null,
      updates.type || null,
      updates.instructions || null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete an assistant by ID
  async deleteAssistant(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM assistants
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the assistant was deleted
  },
}" -> "setDb";
  "assistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  // Fetch all assistants
  getAllAssistants(): AssistantRow[] {
    const stmt = this.db.prepare('SELECT * FROM assistants');
    return stmt.all() as AssistantRow[];
  },

  // Fetch a single assistant by ID
  getAssistantById(id: string): AssistantRow | null {
    const stmt = this.db.prepare('SELECT * FROM assistants WHERE id = ?');
    const result = stmt.get(id);
    return result ? (result as AssistantRow) : null;
  },

  // Add a new assistant
  async addAssistant(assistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the assistant
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO assistants (id, name, description, type, instructions, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, assistant.name, assistant.description, assistant.type, assistant.instructions || null, createdAt, updatedAt);

    return id;
  },

  // Update an existing assistant
  async updateAssistant(id: string, updates: Partial<Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingAssistant = this.db.prepare('SELECT * FROM assistants WHERE id = ?').get(id) as AssistantRow | undefined;

    if (!existingAssistant) {
      throw new Error(`Assistant with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE assistants
      SET
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        type = COALESCE(?, type),
        instructions = COALESCE(?, instructions),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.name || null,
      updates.description || null,
      updates.type || null,
      updates.instructions || null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete an assistant by ID
  async deleteAssistant(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM assistants
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the assistant was deleted
  },
}" -> "getAllAssistants";
  "assistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  // Fetch all assistants
  getAllAssistants(): AssistantRow[] {
    const stmt = this.db.prepare('SELECT * FROM assistants');
    return stmt.all() as AssistantRow[];
  },

  // Fetch a single assistant by ID
  getAssistantById(id: string): AssistantRow | null {
    const stmt = this.db.prepare('SELECT * FROM assistants WHERE id = ?');
    const result = stmt.get(id);
    return result ? (result as AssistantRow) : null;
  },

  // Add a new assistant
  async addAssistant(assistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the assistant
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO assistants (id, name, description, type, instructions, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, assistant.name, assistant.description, assistant.type, assistant.instructions || null, createdAt, updatedAt);

    return id;
  },

  // Update an existing assistant
  async updateAssistant(id: string, updates: Partial<Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingAssistant = this.db.prepare('SELECT * FROM assistants WHERE id = ?').get(id) as AssistantRow | undefined;

    if (!existingAssistant) {
      throw new Error(`Assistant with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE assistants
      SET
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        type = COALESCE(?, type),
        instructions = COALESCE(?, instructions),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.name || null,
      updates.description || null,
      updates.type || null,
      updates.instructions || null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete an assistant by ID
  async deleteAssistant(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM assistants
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the assistant was deleted
  },
}" -> "getAssistantById";
  "assistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  // Fetch all assistants
  getAllAssistants(): AssistantRow[] {
    const stmt = this.db.prepare('SELECT * FROM assistants');
    return stmt.all() as AssistantRow[];
  },

  // Fetch a single assistant by ID
  getAssistantById(id: string): AssistantRow | null {
    const stmt = this.db.prepare('SELECT * FROM assistants WHERE id = ?');
    const result = stmt.get(id);
    return result ? (result as AssistantRow) : null;
  },

  // Add a new assistant
  async addAssistant(assistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the assistant
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO assistants (id, name, description, type, instructions, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, assistant.name, assistant.description, assistant.type, assistant.instructions || null, createdAt, updatedAt);

    return id;
  },

  // Update an existing assistant
  async updateAssistant(id: string, updates: Partial<Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingAssistant = this.db.prepare('SELECT * FROM assistants WHERE id = ?').get(id) as AssistantRow | undefined;

    if (!existingAssistant) {
      throw new Error(`Assistant with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE assistants
      SET
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        type = COALESCE(?, type),
        instructions = COALESCE(?, instructions),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.name || null,
      updates.description || null,
      updates.type || null,
      updates.instructions || null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete an assistant by ID
  async deleteAssistant(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM assistants
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the assistant was deleted
  },
}" -> "addAssistant";
  "assistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  // Fetch all assistants
  getAllAssistants(): AssistantRow[] {
    const stmt = this.db.prepare('SELECT * FROM assistants');
    return stmt.all() as AssistantRow[];
  },

  // Fetch a single assistant by ID
  getAssistantById(id: string): AssistantRow | null {
    const stmt = this.db.prepare('SELECT * FROM assistants WHERE id = ?');
    const result = stmt.get(id);
    return result ? (result as AssistantRow) : null;
  },

  // Add a new assistant
  async addAssistant(assistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the assistant
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO assistants (id, name, description, type, instructions, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, assistant.name, assistant.description, assistant.type, assistant.instructions || null, createdAt, updatedAt);

    return id;
  },

  // Update an existing assistant
  async updateAssistant(id: string, updates: Partial<Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingAssistant = this.db.prepare('SELECT * FROM assistants WHERE id = ?').get(id) as AssistantRow | undefined;

    if (!existingAssistant) {
      throw new Error(`Assistant with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE assistants
      SET
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        type = COALESCE(?, type),
        instructions = COALESCE(?, instructions),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.name || null,
      updates.description || null,
      updates.type || null,
      updates.instructions || null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete an assistant by ID
  async deleteAssistant(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM assistants
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the assistant was deleted
  },
}" -> "updateAssistant";
  "assistantService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  // Fetch all assistants
  getAllAssistants(): AssistantRow[] {
    const stmt = this.db.prepare('SELECT * FROM assistants');
    return stmt.all() as AssistantRow[];
  },

  // Fetch a single assistant by ID
  getAssistantById(id: string): AssistantRow | null {
    const stmt = this.db.prepare('SELECT * FROM assistants WHERE id = ?');
    const result = stmt.get(id);
    return result ? (result as AssistantRow) : null;
  },

  // Add a new assistant
  async addAssistant(assistant: Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the assistant
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO assistants (id, name, description, type, instructions, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, assistant.name, assistant.description, assistant.type, assistant.instructions || null, createdAt, updatedAt);

    return id;
  },

  // Update an existing assistant
  async updateAssistant(id: string, updates: Partial<Omit<Assistant, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingAssistant = this.db.prepare('SELECT * FROM assistants WHERE id = ?').get(id) as AssistantRow | undefined;

    if (!existingAssistant) {
      throw new Error(`Assistant with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE assistants
      SET
        name = COALESCE(?, name),
        description = COALESCE(?, description),
        type = COALESCE(?, type),
        instructions = COALESCE(?, instructions),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.name || null,
      updates.description || null,
      updates.type || null,
      updates.instructions || null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete an assistant by ID
  async deleteAssistant(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM assistants
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the assistant was deleted
  },
}" -> "deleteAssistant";
  "services" -> "feedback.service.ts";
  "feedbackService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb;
  },

  getFeedbackById(id: string): Feedback | null {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE id = ?');
    const result = stmt.get(id) as FeedbackRow;

    if (!result) return null;

    // Map database fields to Feedback interface
    return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };
  },

  getFeedbackByTarget(targetId: string, targetType: 'assistant' | 'memory' | 'task'): Feedback[] {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE target_id = ? AND target_type = ?');
    const results = stmt.all(targetId, targetType) as FeedbackRow[];

    // Map database fields to Feedback interface
    return results.map((result) => ({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    }));
  },

  async addFeedback(feedback: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO feedback (id, target_id, target_type, user_id, rating, comments, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, feedback.targetId, feedback.targetType, feedback.userId || null, feedback.rating, feedback.comments || null, createdAt, updatedAt);

    return id;
  },

  async updateFeedback(id: string, updates: Partial<Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingFeedback = this.db.prepare('SELECT * FROM feedback WHERE id = ?').get(id);

    if (!existingFeedback) {
      throw new Error(`Feedback with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE feedback
      SET
        target_id = COALESCE(?, target_id),
        target_type = COALESCE(?, target_type),
        user_id = COALESCE(?, user_id),
        rating = COALESCE(?, rating),
        comments = COALESCE(?, comments),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.targetId || null, updates.targetType || null, updates.userId || null, updates.rating || null, updates.comments || null, new Date().toISOString(), id);

    return true;
  },

  async deleteFeedback(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM feedback WHERE id = ?');
    const result = stmt.run(id);

    return result.changes > 0;
  },
}" -> "setDb";
  "feedbackService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb;
  },

  getFeedbackById(id: string): Feedback | null {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE id = ?');
    const result = stmt.get(id) as FeedbackRow;

    if (!result) return null;

    // Map database fields to Feedback interface
    return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };
  },

  getFeedbackByTarget(targetId: string, targetType: 'assistant' | 'memory' | 'task'): Feedback[] {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE target_id = ? AND target_type = ?');
    const results = stmt.all(targetId, targetType) as FeedbackRow[];

    // Map database fields to Feedback interface
    return results.map((result) => ({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    }));
  },

  async addFeedback(feedback: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO feedback (id, target_id, target_type, user_id, rating, comments, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, feedback.targetId, feedback.targetType, feedback.userId || null, feedback.rating, feedback.comments || null, createdAt, updatedAt);

    return id;
  },

  async updateFeedback(id: string, updates: Partial<Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingFeedback = this.db.prepare('SELECT * FROM feedback WHERE id = ?').get(id);

    if (!existingFeedback) {
      throw new Error(`Feedback with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE feedback
      SET
        target_id = COALESCE(?, target_id),
        target_type = COALESCE(?, target_type),
        user_id = COALESCE(?, user_id),
        rating = COALESCE(?, rating),
        comments = COALESCE(?, comments),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.targetId || null, updates.targetType || null, updates.userId || null, updates.rating || null, updates.comments || null, new Date().toISOString(), id);

    return true;
  },

  async deleteFeedback(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM feedback WHERE id = ?');
    const result = stmt.run(id);

    return result.changes > 0;
  },
}" -> "getFeedbackById";
  "feedbackService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb;
  },

  getFeedbackById(id: string): Feedback | null {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE id = ?');
    const result = stmt.get(id) as FeedbackRow;

    if (!result) return null;

    // Map database fields to Feedback interface
    return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };
  },

  getFeedbackByTarget(targetId: string, targetType: 'assistant' | 'memory' | 'task'): Feedback[] {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE target_id = ? AND target_type = ?');
    const results = stmt.all(targetId, targetType) as FeedbackRow[];

    // Map database fields to Feedback interface
    return results.map((result) => ({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    }));
  },

  async addFeedback(feedback: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO feedback (id, target_id, target_type, user_id, rating, comments, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, feedback.targetId, feedback.targetType, feedback.userId || null, feedback.rating, feedback.comments || null, createdAt, updatedAt);

    return id;
  },

  async updateFeedback(id: string, updates: Partial<Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingFeedback = this.db.prepare('SELECT * FROM feedback WHERE id = ?').get(id);

    if (!existingFeedback) {
      throw new Error(`Feedback with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE feedback
      SET
        target_id = COALESCE(?, target_id),
        target_type = COALESCE(?, target_type),
        user_id = COALESCE(?, user_id),
        rating = COALESCE(?, rating),
        comments = COALESCE(?, comments),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.targetId || null, updates.targetType || null, updates.userId || null, updates.rating || null, updates.comments || null, new Date().toISOString(), id);

    return true;
  },

  async deleteFeedback(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM feedback WHERE id = ?');
    const result = stmt.run(id);

    return result.changes > 0;
  },
}" -> "getFeedbackByTarget";
  "feedbackService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb;
  },

  getFeedbackById(id: string): Feedback | null {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE id = ?');
    const result = stmt.get(id) as FeedbackRow;

    if (!result) return null;

    // Map database fields to Feedback interface
    return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };
  },

  getFeedbackByTarget(targetId: string, targetType: 'assistant' | 'memory' | 'task'): Feedback[] {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE target_id = ? AND target_type = ?');
    const results = stmt.all(targetId, targetType) as FeedbackRow[];

    // Map database fields to Feedback interface
    return results.map((result) => ({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    }));
  },

  async addFeedback(feedback: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO feedback (id, target_id, target_type, user_id, rating, comments, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, feedback.targetId, feedback.targetType, feedback.userId || null, feedback.rating, feedback.comments || null, createdAt, updatedAt);

    return id;
  },

  async updateFeedback(id: string, updates: Partial<Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingFeedback = this.db.prepare('SELECT * FROM feedback WHERE id = ?').get(id);

    if (!existingFeedback) {
      throw new Error(`Feedback with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE feedback
      SET
        target_id = COALESCE(?, target_id),
        target_type = COALESCE(?, target_type),
        user_id = COALESCE(?, user_id),
        rating = COALESCE(?, rating),
        comments = COALESCE(?, comments),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.targetId || null, updates.targetType || null, updates.userId || null, updates.rating || null, updates.comments || null, new Date().toISOString(), id);

    return true;
  },

  async deleteFeedback(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM feedback WHERE id = ?');
    const result = stmt.run(id);

    return result.changes > 0;
  },
}" -> "addFeedback";
  "feedbackService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb;
  },

  getFeedbackById(id: string): Feedback | null {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE id = ?');
    const result = stmt.get(id) as FeedbackRow;

    if (!result) return null;

    // Map database fields to Feedback interface
    return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };
  },

  getFeedbackByTarget(targetId: string, targetType: 'assistant' | 'memory' | 'task'): Feedback[] {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE target_id = ? AND target_type = ?');
    const results = stmt.all(targetId, targetType) as FeedbackRow[];

    // Map database fields to Feedback interface
    return results.map((result) => ({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    }));
  },

  async addFeedback(feedback: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO feedback (id, target_id, target_type, user_id, rating, comments, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, feedback.targetId, feedback.targetType, feedback.userId || null, feedback.rating, feedback.comments || null, createdAt, updatedAt);

    return id;
  },

  async updateFeedback(id: string, updates: Partial<Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingFeedback = this.db.prepare('SELECT * FROM feedback WHERE id = ?').get(id);

    if (!existingFeedback) {
      throw new Error(`Feedback with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE feedback
      SET
        target_id = COALESCE(?, target_id),
        target_type = COALESCE(?, target_type),
        user_id = COALESCE(?, user_id),
        rating = COALESCE(?, rating),
        comments = COALESCE(?, comments),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.targetId || null, updates.targetType || null, updates.userId || null, updates.rating || null, updates.comments || null, new Date().toISOString(), id);

    return true;
  },

  async deleteFeedback(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM feedback WHERE id = ?');
    const result = stmt.run(id);

    return result.changes > 0;
  },
}" -> "updateFeedback";
  "feedbackService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb;
  },

  getFeedbackById(id: string): Feedback | null {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE id = ?');
    const result = stmt.get(id) as FeedbackRow;

    if (!result) return null;

    // Map database fields to Feedback interface
    return {
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    };
  },

  getFeedbackByTarget(targetId: string, targetType: 'assistant' | 'memory' | 'task'): Feedback[] {
    const stmt = this.db.prepare('SELECT * FROM feedback WHERE target_id = ? AND target_type = ?');
    const results = stmt.all(targetId, targetType) as FeedbackRow[];

    // Map database fields to Feedback interface
    return results.map((result) => ({
      id: result.id,
      targetId: result.target_id,
      targetType: result.target_type,
      userId: result.user_id || undefined,
      rating: result.rating,
      comments: result.comments || undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    }));
  },

  async addFeedback(feedback: Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO feedback (id, target_id, target_type, user_id, rating, comments, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, feedback.targetId, feedback.targetType, feedback.userId || null, feedback.rating, feedback.comments || null, createdAt, updatedAt);

    return id;
  },

  async updateFeedback(id: string, updates: Partial<Omit<Feedback, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingFeedback = this.db.prepare('SELECT * FROM feedback WHERE id = ?').get(id);

    if (!existingFeedback) {
      throw new Error(`Feedback with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE feedback
      SET
        target_id = COALESCE(?, target_id),
        target_type = COALESCE(?, target_type),
        user_id = COALESCE(?, user_id),
        rating = COALESCE(?, rating),
        comments = COALESCE(?, comments),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.targetId || null, updates.targetType || null, updates.userId || null, updates.rating || null, updates.comments || null, new Date().toISOString(), id);

    return true;
  },

  async deleteFeedback(id: string): Promise<boolean> {
    const stmt = this.db.prepare('DELETE FROM feedback WHERE id = ?');
    const result = stmt.run(id);

    return result.changes > 0;
  },
}" -> "deleteFeedback";
  "services" -> "focused-memory.service.ts";
  "focusedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getFocusedMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM memory_focus_rules fr
      JOIN focused_memories fm ON fr.id = fm.memory_focus_id
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fr.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getFocusedMemories(memoryFocusId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM focused_memories fm
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fm.memory_focus_id = ?
    `
      )
      .all(memoryFocusId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async addFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0; // Returns true if the memory was successfully added
    } catch {
      return false; // Gracefully handle duplicates or constraint violations
    }
  },
  async removeFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM focused_memories
      WHERE memory_focus_id = ? AND memory_id = ?
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0;
    } catch {
      return false;
    }
  },
  async updateFocusedMemories(memoryFocusId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
    DELETE FROM focused_memories
    WHERE memory_focus_id = ?
  `);

      const insertStmt = this.db.prepare(`
    INSERT INTO focused_memories (memory_focus_id, memory_id)
    VALUES (?, ?)
  `);

      // Remove all existing associations
      deleteStmt.run(memoryFocusId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(memoryFocusId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "setDb";
  "focusedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getFocusedMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM memory_focus_rules fr
      JOIN focused_memories fm ON fr.id = fm.memory_focus_id
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fr.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getFocusedMemories(memoryFocusId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM focused_memories fm
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fm.memory_focus_id = ?
    `
      )
      .all(memoryFocusId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async addFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0; // Returns true if the memory was successfully added
    } catch {
      return false; // Gracefully handle duplicates or constraint violations
    }
  },
  async removeFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM focused_memories
      WHERE memory_focus_id = ? AND memory_id = ?
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0;
    } catch {
      return false;
    }
  },
  async updateFocusedMemories(memoryFocusId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
    DELETE FROM focused_memories
    WHERE memory_focus_id = ?
  `);

      const insertStmt = this.db.prepare(`
    INSERT INTO focused_memories (memory_focus_id, memory_id)
    VALUES (?, ?)
  `);

      // Remove all existing associations
      deleteStmt.run(memoryFocusId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(memoryFocusId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "getFocusedMemoriesByAssistantId";
  "focusedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getFocusedMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM memory_focus_rules fr
      JOIN focused_memories fm ON fr.id = fm.memory_focus_id
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fr.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getFocusedMemories(memoryFocusId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM focused_memories fm
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fm.memory_focus_id = ?
    `
      )
      .all(memoryFocusId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async addFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0; // Returns true if the memory was successfully added
    } catch {
      return false; // Gracefully handle duplicates or constraint violations
    }
  },
  async removeFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM focused_memories
      WHERE memory_focus_id = ? AND memory_id = ?
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0;
    } catch {
      return false;
    }
  },
  async updateFocusedMemories(memoryFocusId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
    DELETE FROM focused_memories
    WHERE memory_focus_id = ?
  `);

      const insertStmt = this.db.prepare(`
    INSERT INTO focused_memories (memory_focus_id, memory_id)
    VALUES (?, ?)
  `);

      // Remove all existing associations
      deleteStmt.run(memoryFocusId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(memoryFocusId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "getFocusedMemories";
  "focusedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getFocusedMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM memory_focus_rules fr
      JOIN focused_memories fm ON fr.id = fm.memory_focus_id
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fr.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getFocusedMemories(memoryFocusId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM focused_memories fm
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fm.memory_focus_id = ?
    `
      )
      .all(memoryFocusId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async addFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0; // Returns true if the memory was successfully added
    } catch {
      return false; // Gracefully handle duplicates or constraint violations
    }
  },
  async removeFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM focused_memories
      WHERE memory_focus_id = ? AND memory_id = ?
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0;
    } catch {
      return false;
    }
  },
  async updateFocusedMemories(memoryFocusId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
    DELETE FROM focused_memories
    WHERE memory_focus_id = ?
  `);

      const insertStmt = this.db.prepare(`
    INSERT INTO focused_memories (memory_focus_id, memory_id)
    VALUES (?, ?)
  `);

      // Remove all existing associations
      deleteStmt.run(memoryFocusId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(memoryFocusId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "addFocusedMemory";
  "focusedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getFocusedMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM memory_focus_rules fr
      JOIN focused_memories fm ON fr.id = fm.memory_focus_id
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fr.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getFocusedMemories(memoryFocusId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM focused_memories fm
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fm.memory_focus_id = ?
    `
      )
      .all(memoryFocusId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async addFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0; // Returns true if the memory was successfully added
    } catch {
      return false; // Gracefully handle duplicates or constraint violations
    }
  },
  async removeFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM focused_memories
      WHERE memory_focus_id = ? AND memory_id = ?
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0;
    } catch {
      return false;
    }
  },
  async updateFocusedMemories(memoryFocusId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
    DELETE FROM focused_memories
    WHERE memory_focus_id = ?
  `);

      const insertStmt = this.db.prepare(`
    INSERT INTO focused_memories (memory_focus_id, memory_id)
    VALUES (?, ?)
  `);

      // Remove all existing associations
      deleteStmt.run(memoryFocusId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(memoryFocusId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "removeFocusedMemory";
  "focusedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getFocusedMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM memory_focus_rules fr
      JOIN focused_memories fm ON fr.id = fm.memory_focus_id
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fr.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getFocusedMemories(memoryFocusId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM focused_memories fm
      JOIN memories m ON fm.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE fm.memory_focus_id = ?
    `
      )
      .all(memoryFocusId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async addFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0; // Returns true if the memory was successfully added
    } catch {
      return false; // Gracefully handle duplicates or constraint violations
    }
  },
  async removeFocusedMemory(memoryFocusId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM focused_memories
      WHERE memory_focus_id = ? AND memory_id = ?
    `);
      const result = stmt.run(memoryFocusId, memoryId);
      return result.changes > 0;
    } catch {
      return false;
    }
  },
  async updateFocusedMemories(memoryFocusId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
    DELETE FROM focused_memories
    WHERE memory_focus_id = ?
  `);

      const insertStmt = this.db.prepare(`
    INSERT INTO focused_memories (memory_focus_id, memory_id)
    VALUES (?, ?)
  `);

      // Remove all existing associations
      deleteStmt.run(memoryFocusId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(memoryFocusId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "updateFocusedMemories";
  "services" -> "gpt-api";
  "gpt-api" -> "gpt-api-assistant.ts";
  "gpt-api-assistant.ts" -> "createAssistant";
  "gpt-api-assistant.ts" -> "getAssistantById";
  "gpt-api-assistant.ts" -> "updateAssistant";
  "gpt-api-assistant.ts" -> "deleteAssistant";
  "gpt-api" -> "gpt-api-chat-completion.ts";
  "gpt-api-chat-completion.ts" -> "createChatCompletion";
  "gpt-api-chat-completion.ts" -> "extractChatReply";
  "gpt-api-chat-completion.ts" -> "generateChatReply";
  "gpt-api-chat-completion.ts" -> "extendConversation";
  "gpt-api" -> "gpt-api-connector.ts";
  "gpt-api-connector.ts" -> "initOpenAI";
  "gpt-api-connector.ts" -> "getOpenAI";
  "gpt-api" -> "gpt-api-model-helper.ts";
  "gpt-api-model-helper.ts" -> "evaluatePrompt";
  "gpt-api-model-helper.ts" -> "estimateTokens";
  "gpt-api-model-helper.ts" -> "getSuitableModels";
  "gpt-api-model-helper.ts" -> "estimateTokensFromWords";
  "gpt-api-model-helper.ts" -> "estimateTokensForResponse";
  "gpt-api-model-helper.ts" -> "estimateTokensFromPrompt";
  "gpt-api" -> "gpt-api-models.model.ts";
  "gpt-api" -> "gpt-api-thread.ts";
  "gpt-api-thread.ts" -> "createNewThread";
  "gpt-api-thread.ts" -> "addThreadMessage";
  "gpt-api-thread.ts" -> "addMultipleMessages";
  "gpt-api-thread.ts" -> "fetchThreadMessages";
  "gpt-api-thread.ts" -> "startAssistantRun";
  "gpt-api-thread.ts" -> "waitForRunCompletion";
  "gpt-api-thread.ts" -> "getRunDetails";
  "gpt-api-thread.ts" -> "extractAssistantReply";
  "gpt-api-thread.ts" -> "getAssistantReply";
  "gpt-api-thread.ts" -> "queryAssistant";
  "gpt-api" -> "gpt-api.config.ts";
  "services" -> "memory-extra.service.ts";
  "memoryExtraService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch all memories with their associated tags.
   */
  async getAllMemories(): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
      `
      )
      .all() as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Fetch memories associated with specific tags.
   */
  async getMemoriesByTags(tags: string[]): Promise<Memory[]> {
    if (tags.length === 0) {
      throw new Error('Tags array cannot be empty.');
    }

    const placeholders = tags.map(() => '?').join(', ');
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
        WHERE t.name IN (${placeholders})
      `
      )
      .all(...tags) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Update tags associated with a memory.
   */
  async updateMemoryTags(memoryId: string, newTags: string[]): Promise<boolean> {
    // Ensure memory exists
    const memoryRow = this.db
      .prepare(
        `
      SELECT * 
      FROM memories 
      WHERE id = ?
    `
      )
      .get(memoryId) as MemoryRow | undefined;

    if (!memoryRow) {
      throw new Error(`Memory with ID ${memoryId} not found.`);
    }

    // Fetch existing tags for the memory
    const existingTags = this.db
      .prepare(
        `
      SELECT t.name 
      FROM memory_tags mt
      JOIN tags t ON mt.tag_id = t.id
      WHERE mt.memory_id = ?
    `
      )
      .all(memoryId) as { name: string }[];

    const currentTagNames = existingTags.map((tag) => tag.name);
    const tagsToAdd = newTags.filter((tagName) => !currentTagNames.includes(tagName));
    const tagsToRemove = currentTagNames.filter((tagName) => !newTags.includes(tagName));

    // Add new tags
    for (const tagName of tagsToAdd) {
      // Ensure the tag exists
      let tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (!tag) {
        const newTagId = generateUniqueId();
        this.db
          .prepare(
            `
        INSERT INTO tags (id, name)
        VALUES (?, ?)
      `
          )
          .run(newTagId, tagName);
        tag = { id: newTagId };
      }

      // Associate the tag with the memory
      this.db
        .prepare(
          `
      INSERT OR IGNORE INTO memory_tags (memory_id, tag_id)
      VALUES (?, ?)
    `
        )
        .run(memoryId, tag.id);
    }

    // Remove old tags
    for (const tagName of tagsToRemove) {
      const tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (tag) {
        this.db
          .prepare(
            `
        DELETE FROM memory_tags 
        WHERE memory_id = ? AND tag_id = ?
      `
          )
          .run(memoryId, tag.id);
      }
    }

    return true;
  },
}" -> "setDb";
  "memoryExtraService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch all memories with their associated tags.
   */
  async getAllMemories(): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
      `
      )
      .all() as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Fetch memories associated with specific tags.
   */
  async getMemoriesByTags(tags: string[]): Promise<Memory[]> {
    if (tags.length === 0) {
      throw new Error('Tags array cannot be empty.');
    }

    const placeholders = tags.map(() => '?').join(', ');
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
        WHERE t.name IN (${placeholders})
      `
      )
      .all(...tags) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Update tags associated with a memory.
   */
  async updateMemoryTags(memoryId: string, newTags: string[]): Promise<boolean> {
    // Ensure memory exists
    const memoryRow = this.db
      .prepare(
        `
      SELECT * 
      FROM memories 
      WHERE id = ?
    `
      )
      .get(memoryId) as MemoryRow | undefined;

    if (!memoryRow) {
      throw new Error(`Memory with ID ${memoryId} not found.`);
    }

    // Fetch existing tags for the memory
    const existingTags = this.db
      .prepare(
        `
      SELECT t.name 
      FROM memory_tags mt
      JOIN tags t ON mt.tag_id = t.id
      WHERE mt.memory_id = ?
    `
      )
      .all(memoryId) as { name: string }[];

    const currentTagNames = existingTags.map((tag) => tag.name);
    const tagsToAdd = newTags.filter((tagName) => !currentTagNames.includes(tagName));
    const tagsToRemove = currentTagNames.filter((tagName) => !newTags.includes(tagName));

    // Add new tags
    for (const tagName of tagsToAdd) {
      // Ensure the tag exists
      let tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (!tag) {
        const newTagId = generateUniqueId();
        this.db
          .prepare(
            `
        INSERT INTO tags (id, name)
        VALUES (?, ?)
      `
          )
          .run(newTagId, tagName);
        tag = { id: newTagId };
      }

      // Associate the tag with the memory
      this.db
        .prepare(
          `
      INSERT OR IGNORE INTO memory_tags (memory_id, tag_id)
      VALUES (?, ?)
    `
        )
        .run(memoryId, tag.id);
    }

    // Remove old tags
    for (const tagName of tagsToRemove) {
      const tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (tag) {
        this.db
          .prepare(
            `
        DELETE FROM memory_tags 
        WHERE memory_id = ? AND tag_id = ?
      `
          )
          .run(memoryId, tag.id);
      }
    }

    return true;
  },
}" -> "getAllMemories";
  "memoryExtraService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch all memories with their associated tags.
   */
  async getAllMemories(): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
      `
      )
      .all() as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Fetch memories associated with specific tags.
   */
  async getMemoriesByTags(tags: string[]): Promise<Memory[]> {
    if (tags.length === 0) {
      throw new Error('Tags array cannot be empty.');
    }

    const placeholders = tags.map(() => '?').join(', ');
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
        WHERE t.name IN (${placeholders})
      `
      )
      .all(...tags) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Update tags associated with a memory.
   */
  async updateMemoryTags(memoryId: string, newTags: string[]): Promise<boolean> {
    // Ensure memory exists
    const memoryRow = this.db
      .prepare(
        `
      SELECT * 
      FROM memories 
      WHERE id = ?
    `
      )
      .get(memoryId) as MemoryRow | undefined;

    if (!memoryRow) {
      throw new Error(`Memory with ID ${memoryId} not found.`);
    }

    // Fetch existing tags for the memory
    const existingTags = this.db
      .prepare(
        `
      SELECT t.name 
      FROM memory_tags mt
      JOIN tags t ON mt.tag_id = t.id
      WHERE mt.memory_id = ?
    `
      )
      .all(memoryId) as { name: string }[];

    const currentTagNames = existingTags.map((tag) => tag.name);
    const tagsToAdd = newTags.filter((tagName) => !currentTagNames.includes(tagName));
    const tagsToRemove = currentTagNames.filter((tagName) => !newTags.includes(tagName));

    // Add new tags
    for (const tagName of tagsToAdd) {
      // Ensure the tag exists
      let tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (!tag) {
        const newTagId = generateUniqueId();
        this.db
          .prepare(
            `
        INSERT INTO tags (id, name)
        VALUES (?, ?)
      `
          )
          .run(newTagId, tagName);
        tag = { id: newTagId };
      }

      // Associate the tag with the memory
      this.db
        .prepare(
          `
      INSERT OR IGNORE INTO memory_tags (memory_id, tag_id)
      VALUES (?, ?)
    `
        )
        .run(memoryId, tag.id);
    }

    // Remove old tags
    for (const tagName of tagsToRemove) {
      const tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (tag) {
        this.db
          .prepare(
            `
        DELETE FROM memory_tags 
        WHERE memory_id = ? AND tag_id = ?
      `
          )
          .run(memoryId, tag.id);
      }
    }

    return true;
  },
}" -> "getMemoriesByTags";
  "memoryExtraService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  /**
   * Fetch all memories with their associated tags.
   */
  async getAllMemories(): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
      `
      )
      .all() as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Fetch memories associated with specific tags.
   */
  async getMemoriesByTags(tags: string[]): Promise<Memory[]> {
    if (tags.length === 0) {
      throw new Error('Tags array cannot be empty.');
    }

    const placeholders = tags.map(() => '?').join(', ');
    const rows = this.db
      .prepare(
        `
        SELECT m.*, t.id AS tag_id, t.name AS tag_name
        FROM memories m
        LEFT JOIN memory_tags mt ON m.id = mt.memory_id
        LEFT JOIN tags t ON mt.tag_id = t.id
        WHERE t.name IN (${placeholders})
      `
      )
      .all(...tags) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  /**
   * Update tags associated with a memory.
   */
  async updateMemoryTags(memoryId: string, newTags: string[]): Promise<boolean> {
    // Ensure memory exists
    const memoryRow = this.db
      .prepare(
        `
      SELECT * 
      FROM memories 
      WHERE id = ?
    `
      )
      .get(memoryId) as MemoryRow | undefined;

    if (!memoryRow) {
      throw new Error(`Memory with ID ${memoryId} not found.`);
    }

    // Fetch existing tags for the memory
    const existingTags = this.db
      .prepare(
        `
      SELECT t.name 
      FROM memory_tags mt
      JOIN tags t ON mt.tag_id = t.id
      WHERE mt.memory_id = ?
    `
      )
      .all(memoryId) as { name: string }[];

    const currentTagNames = existingTags.map((tag) => tag.name);
    const tagsToAdd = newTags.filter((tagName) => !currentTagNames.includes(tagName));
    const tagsToRemove = currentTagNames.filter((tagName) => !newTags.includes(tagName));

    // Add new tags
    for (const tagName of tagsToAdd) {
      // Ensure the tag exists
      let tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (!tag) {
        const newTagId = generateUniqueId();
        this.db
          .prepare(
            `
        INSERT INTO tags (id, name)
        VALUES (?, ?)
      `
          )
          .run(newTagId, tagName);
        tag = { id: newTagId };
      }

      // Associate the tag with the memory
      this.db
        .prepare(
          `
      INSERT OR IGNORE INTO memory_tags (memory_id, tag_id)
      VALUES (?, ?)
    `
        )
        .run(memoryId, tag.id);
    }

    // Remove old tags
    for (const tagName of tagsToRemove) {
      const tag = this.db
        .prepare(
          `
        SELECT id 
        FROM tags 
        WHERE name = ?
      `
        )
        .get(tagName) as { id: string } | undefined;

      if (tag) {
        this.db
          .prepare(
            `
        DELETE FROM memory_tags 
        WHERE memory_id = ? AND tag_id = ?
      `
          )
          .run(memoryId, tag.id);
      }
    }

    return true;
  },
}" -> "updateMemoryTags";
  "services" -> "memory-focus-rule.service.ts";
  "memoryFocusRuleService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoryFocusRules(assistantId: string): Promise<MemoryFocusRule | null> {
    const row = this.db
      .prepare(
        `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
      )
      .get(assistantId) as MemoryFocusRuleRow | undefined;

    return row ? transformMemoryFocusRuleRow(row) : null;
  },
  async updateMemoryFocusRule(id: string, updates: Partial<Omit<MemoryFocusRule, 'id' | 'assistantId' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const stmt = this.db.prepare(`
      UPDATE memory_focus_rules
      SET 
        maxResults = COALESCE(?, maxResults),
        relationshipTypes = COALESCE(?, relationshipTypes),
        priorityTags = COALESCE(?, priorityTags),
        updatedAt = ?
      WHERE id = ?
    `);

    const result = stmt.run(
      updates.maxResults || null,
      updates.relationshipTypes ? JSON.stringify(updates.relationshipTypes) : null,
      updates.priorityTags ? JSON.stringify(updates.priorityTags) : null,
      new Date().toISOString(),
      id
    );

    return result.changes > 0; // Returns true if the rule was updated
  },
  async removeMemoryFocusRule(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM memory_focus_rules
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the rule was removed
  },
}" -> "setDb";
  "memoryFocusRuleService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoryFocusRules(assistantId: string): Promise<MemoryFocusRule | null> {
    const row = this.db
      .prepare(
        `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
      )
      .get(assistantId) as MemoryFocusRuleRow | undefined;

    return row ? transformMemoryFocusRuleRow(row) : null;
  },
  async updateMemoryFocusRule(id: string, updates: Partial<Omit<MemoryFocusRule, 'id' | 'assistantId' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const stmt = this.db.prepare(`
      UPDATE memory_focus_rules
      SET 
        maxResults = COALESCE(?, maxResults),
        relationshipTypes = COALESCE(?, relationshipTypes),
        priorityTags = COALESCE(?, priorityTags),
        updatedAt = ?
      WHERE id = ?
    `);

    const result = stmt.run(
      updates.maxResults || null,
      updates.relationshipTypes ? JSON.stringify(updates.relationshipTypes) : null,
      updates.priorityTags ? JSON.stringify(updates.priorityTags) : null,
      new Date().toISOString(),
      id
    );

    return result.changes > 0; // Returns true if the rule was updated
  },
  async removeMemoryFocusRule(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM memory_focus_rules
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the rule was removed
  },
}" -> "getMemoryFocusRules";
  "memoryFocusRuleService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoryFocusRules(assistantId: string): Promise<MemoryFocusRule | null> {
    const row = this.db
      .prepare(
        `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
      )
      .get(assistantId) as MemoryFocusRuleRow | undefined;

    return row ? transformMemoryFocusRuleRow(row) : null;
  },
  async updateMemoryFocusRule(id: string, updates: Partial<Omit<MemoryFocusRule, 'id' | 'assistantId' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const stmt = this.db.prepare(`
      UPDATE memory_focus_rules
      SET 
        maxResults = COALESCE(?, maxResults),
        relationshipTypes = COALESCE(?, relationshipTypes),
        priorityTags = COALESCE(?, priorityTags),
        updatedAt = ?
      WHERE id = ?
    `);

    const result = stmt.run(
      updates.maxResults || null,
      updates.relationshipTypes ? JSON.stringify(updates.relationshipTypes) : null,
      updates.priorityTags ? JSON.stringify(updates.priorityTags) : null,
      new Date().toISOString(),
      id
    );

    return result.changes > 0; // Returns true if the rule was updated
  },
  async removeMemoryFocusRule(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM memory_focus_rules
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the rule was removed
  },
}" -> "updateMemoryFocusRule";
  "memoryFocusRuleService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoryFocusRules(assistantId: string): Promise<MemoryFocusRule | null> {
    const row = this.db
      .prepare(
        `
      SELECT * 
      FROM memory_focus_rules 
      WHERE assistant_id = ?
    `
      )
      .get(assistantId) as MemoryFocusRuleRow | undefined;

    return row ? transformMemoryFocusRuleRow(row) : null;
  },
  async updateMemoryFocusRule(id: string, updates: Partial<Omit<MemoryFocusRule, 'id' | 'assistantId' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const stmt = this.db.prepare(`
      UPDATE memory_focus_rules
      SET 
        maxResults = COALESCE(?, maxResults),
        relationshipTypes = COALESCE(?, relationshipTypes),
        priorityTags = COALESCE(?, priorityTags),
        updatedAt = ?
      WHERE id = ?
    `);

    const result = stmt.run(
      updates.maxResults || null,
      updates.relationshipTypes ? JSON.stringify(updates.relationshipTypes) : null,
      updates.priorityTags ? JSON.stringify(updates.priorityTags) : null,
      new Date().toISOString(),
      id
    );

    return result.changes > 0; // Returns true if the rule was updated
  },
  async removeMemoryFocusRule(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM memory_focus_rules
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the rule was removed
  },
}" -> "removeMemoryFocusRule";
  "services" -> "memory.service.ts";
  "memoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async addMemory(memory: Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
    INSERT INTO memories (id, type,  description, data, createdAt, updatedAt)
    VALUES (?, ?, ?, ?, ?, ?)
  `);

    stmt.run(id, memory.type, memory.description || null, memory.data ? JSON.stringify(memory.data) : null, createdAt, updatedAt);

    return id;
  },

  async removeMemory(memoryId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM memories WHERE id = ?');
    stmt.run(memoryId);
  },

  async updateMemory(id: string, updates: Partial<Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>>): Promise<void> {
    const stmt = this.db.prepare(`
    UPDATE memories
    SET
      type = COALESCE(?, type),
      description = COALESCE(?, description),
      data = COALESCE(?, data),
      updatedAt = ?
    WHERE id = ?
  `);

    stmt.run(updates.type || null, updates.description || null, updates.data ? JSON.stringify(updates.data) : null, new Date().toISOString(), id);
  },
}" -> "setDb";
  "memoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async addMemory(memory: Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
    INSERT INTO memories (id, type,  description, data, createdAt, updatedAt)
    VALUES (?, ?, ?, ?, ?, ?)
  `);

    stmt.run(id, memory.type, memory.description || null, memory.data ? JSON.stringify(memory.data) : null, createdAt, updatedAt);

    return id;
  },

  async removeMemory(memoryId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM memories WHERE id = ?');
    stmt.run(memoryId);
  },

  async updateMemory(id: string, updates: Partial<Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>>): Promise<void> {
    const stmt = this.db.prepare(`
    UPDATE memories
    SET
      type = COALESCE(?, type),
      description = COALESCE(?, description),
      data = COALESCE(?, data),
      updatedAt = ?
    WHERE id = ?
  `);

    stmt.run(updates.type || null, updates.description || null, updates.data ? JSON.stringify(updates.data) : null, new Date().toISOString(), id);
  },
}" -> "addMemory";
  "memoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async addMemory(memory: Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
    INSERT INTO memories (id, type,  description, data, createdAt, updatedAt)
    VALUES (?, ?, ?, ?, ?, ?)
  `);

    stmt.run(id, memory.type, memory.description || null, memory.data ? JSON.stringify(memory.data) : null, createdAt, updatedAt);

    return id;
  },

  async removeMemory(memoryId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM memories WHERE id = ?');
    stmt.run(memoryId);
  },

  async updateMemory(id: string, updates: Partial<Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>>): Promise<void> {
    const stmt = this.db.prepare(`
    UPDATE memories
    SET
      type = COALESCE(?, type),
      description = COALESCE(?, description),
      data = COALESCE(?, data),
      updatedAt = ?
    WHERE id = ?
  `);

    stmt.run(updates.type || null, updates.description || null, updates.data ? JSON.stringify(updates.data) : null, new Date().toISOString(), id);
  },
}" -> "removeMemory";
  "memoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async addMemory(memory: Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
    INSERT INTO memories (id, type,  description, data, createdAt, updatedAt)
    VALUES (?, ?, ?, ?, ?, ?)
  `);

    stmt.run(id, memory.type, memory.description || null, memory.data ? JSON.stringify(memory.data) : null, createdAt, updatedAt);

    return id;
  },

  async removeMemory(memoryId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM memories WHERE id = ?');
    stmt.run(memoryId);
  },

  async updateMemory(id: string, updates: Partial<Omit<Memory, 'id' | 'tags' | 'createdAt' | 'updatedAt'>>): Promise<void> {
    const stmt = this.db.prepare(`
    UPDATE memories
    SET
      type = COALESCE(?, type),
      description = COALESCE(?, description),
      data = COALESCE(?, data),
      updatedAt = ?
    WHERE id = ?
  `);

    stmt.run(updates.type || null, updates.description || null, updates.data ? JSON.stringify(updates.data) : null, new Date().toISOString(), id);
  },
}" -> "updateMemory";
  "services" -> "owned-memory.service.ts";
  "ownedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getOwnedMemories(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  async addOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async removeOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ? AND memory_id = ?
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async updateOwnedMemories(assistantId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ?
    `);

      const insertStmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      // Remove all existing associations
      deleteStmt.run(assistantId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(assistantId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "setDb";
  "ownedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getOwnedMemories(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  async addOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async removeOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ? AND memory_id = ?
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async updateOwnedMemories(assistantId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ?
    `);

      const insertStmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      // Remove all existing associations
      deleteStmt.run(assistantId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(assistantId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "getMemoriesByAssistantId";
  "ownedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getOwnedMemories(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  async addOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async removeOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ? AND memory_id = ?
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async updateOwnedMemories(assistantId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ?
    `);

      const insertStmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      // Remove all existing associations
      deleteStmt.run(assistantId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(assistantId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "getOwnedMemories";
  "ownedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getOwnedMemories(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  async addOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async removeOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ? AND memory_id = ?
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async updateOwnedMemories(assistantId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ?
    `);

      const insertStmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      // Remove all existing associations
      deleteStmt.run(assistantId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(assistantId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "addOwnedMemory";
  "ownedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getOwnedMemories(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  async addOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async removeOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ? AND memory_id = ?
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async updateOwnedMemories(assistantId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ?
    `);

      const insertStmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      // Remove all existing associations
      deleteStmt.run(assistantId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(assistantId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "removeOwnedMemory";
  "ownedMemoryService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },
  async getMemoriesByAssistantId(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },
  async getOwnedMemories(assistantId: string): Promise<Memory[]> {
    const rows = this.db
      .prepare(
        `
      SELECT m.*, t.id AS tag_id, t.name AS tag_name
      FROM owned_memories om
      JOIN memories m ON om.memory_id = m.id
      LEFT JOIN memory_tags mt ON m.id = mt.memory_id
      LEFT JOIN tags t ON mt.tag_id = t.id
      WHERE om.assistant_id = ?
    `
      )
      .all(assistantId) as (MemoryRow & { tag_id: string | null; tag_name: string | null })[];

    // Group tags by memory ID and transform memories
    const memoryMap = new Map<string, { row: MemoryRow; tags: Tag[] }>();

    rows.forEach((row) => {
      if (!memoryMap.has(row.id)) {
        memoryMap.set(row.id, { row, tags: [] });
      }
      if (row.tag_id && row.tag_name) {
        memoryMap.get(row.id)?.tags.push({ id: row.tag_id, name: row.tag_name });
      }
    });

    return Array.from(memoryMap.values()).map(({ row, tags }) => transformMemoryRow(row, tags));
  },

  async addOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async removeOwnedMemory(assistantId: string, memoryId: string): Promise<boolean> {
    try {
      const stmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ? AND memory_id = ?
    `);

      const result = stmt.run(assistantId, memoryId);

      return result.changes > 0;
    } catch {
      return false;
    }
  },

  async updateOwnedMemories(assistantId: string, memoryIds: string[]): Promise<boolean> {
    try {
      const deleteStmt = this.db.prepare(`
      DELETE FROM owned_memories
      WHERE assistant_id = ?
    `);

      const insertStmt = this.db.prepare(`
      INSERT INTO owned_memories (assistant_id, memory_id)
      VALUES (?, ?)
    `);

      // Remove all existing associations
      deleteStmt.run(assistantId);

      // Add the new set of memories
      for (const memoryId of memoryIds) {
        insertStmt.run(assistantId, memoryId);
      }
      return true;
    } catch {
      return false;
    }
  },
}" -> "updateOwnedMemories";
  "services" -> "relationship-graph.service.ts";
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" -> "setDb";
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" -> "getAllRelationships";
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" -> "getRelationshipsBySource";
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" -> "addRelationship";
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" -> "updateRelationship";
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" -> "deleteRelationship";
  "relationshipGraphService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override database instance
  },

  // Fetch all relationships
  getAllRelationships(): RelationshipGraph[] {
    const stmt = this.db.prepare('SELECT * FROM relationship_graph');
    const results = stmt.all() as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Fetch relationships by source ID and type
  getRelationshipsBySource(targetId: string, type: RelationshipGraph['type']): RelationshipGraph[] {
    const stmt = this.db.prepare(`
    SELECT * 
    FROM relationship_graph 
    WHERE target_id = ? AND type = ?
  `);
    const results = stmt.all(targetId, type) as RelationshipGraphRow[];
    return results.map((row) => this.transformRow(row));
  },

  // Add a new relationship
  async addRelationship(relationship: Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId();
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO relationship_graph (id, type, target_id, relationship_type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, relationship.type, relationship.targetId, relationship.relationshipType, createdAt, updatedAt);

    return id;
  },

  // Update an existing relationship
  async updateRelationship(id: string, updates: Partial<Omit<RelationshipGraph, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existing = this.db.prepare('SELECT * FROM relationship_graph WHERE id = ?').get(id);
    if (!existing) {
      throw new Error(`Relationship with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE relationship_graph
      SET
        type = COALESCE(?, type),
        target_id = COALESCE(?, target_id),
        relationship_type = COALESCE(?, relationship_type),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(updates.type || null, updates.targetId || null, updates.relationshipType || null, new Date().toISOString(), id);

    return true;
  },

  // Delete a relationship
  async deleteRelationship(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM relationship_graph
      WHERE id = ?
    `);

    const result = stmt.run(id);
    return result.changes > 0; // Returns true if the relationship was deleted
  },

  // Transform database row to RelationshipGraph object
  transformRow(row: RelationshipGraphRow): RelationshipGraph {
    return {
      id: row.id,
      type: row.type,
      targetId: row.target_id,
      relationshipType: row.relationship_type,
      createdAt: new Date(row.createdAt),
      updatedAt: new Date(row.updatedAt),
    };
  },
}" -> "transformRow";
  "services" -> "tag-extra.service.ts";
  "tagExtraService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override the database instance
  },

  // Fetch tags associated with an entity
  getTagsByEntity(entityId: string, entityType: 'memory' | 'assistant' | 'task'): Tag[] {
    const tableName = this.getTableNameForEntity(entityType);
    const stmt = this.db.prepare(`
      SELECT t.* 
      FROM ${tableName} et
      JOIN tags t ON et.tag_id = t.id
      WHERE et.${entityType}_id = ?
    `);
    return stmt.all(entityId) as Tag[];
  },

  // Associate a tag with an entity
  async addTagToEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      INSERT INTO ${tableName} (${entityType}_id, tag_id)
      VALUES (?, ?)
    `);

    try {
      stmt.run(entityId, tagId);
      return true;
    } catch (error) {
      console.error('Error adding tag to entity:', error);
      return false;
    }
  },

  // Remove a tag from an entity
  async removeTagFromEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      DELETE FROM ${tableName}
      WHERE ${entityType}_id = ? AND tag_id = ?
    `);

    const result = stmt.run(entityId, tagId);
    return result.changes > 0;
  },

  // Utility: Map entity type to table name
  getTableNameForEntity(entityType: 'memory' | 'assistant' | 'task'): string {
    const tableMap = {
      memory: 'memory_tags',
      assistant: 'assistant_tags',
      task: 'task_tags',
    };
    return tableMap[entityType];
  },
}" -> "setDb";
  "tagExtraService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override the database instance
  },

  // Fetch tags associated with an entity
  getTagsByEntity(entityId: string, entityType: 'memory' | 'assistant' | 'task'): Tag[] {
    const tableName = this.getTableNameForEntity(entityType);
    const stmt = this.db.prepare(`
      SELECT t.* 
      FROM ${tableName} et
      JOIN tags t ON et.tag_id = t.id
      WHERE et.${entityType}_id = ?
    `);
    return stmt.all(entityId) as Tag[];
  },

  // Associate a tag with an entity
  async addTagToEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      INSERT INTO ${tableName} (${entityType}_id, tag_id)
      VALUES (?, ?)
    `);

    try {
      stmt.run(entityId, tagId);
      return true;
    } catch (error) {
      console.error('Error adding tag to entity:', error);
      return false;
    }
  },

  // Remove a tag from an entity
  async removeTagFromEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      DELETE FROM ${tableName}
      WHERE ${entityType}_id = ? AND tag_id = ?
    `);

    const result = stmt.run(entityId, tagId);
    return result.changes > 0;
  },

  // Utility: Map entity type to table name
  getTableNameForEntity(entityType: 'memory' | 'assistant' | 'task'): string {
    const tableMap = {
      memory: 'memory_tags',
      assistant: 'assistant_tags',
      task: 'task_tags',
    };
    return tableMap[entityType];
  },
}" -> "getTagsByEntity";
  "tagExtraService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override the database instance
  },

  // Fetch tags associated with an entity
  getTagsByEntity(entityId: string, entityType: 'memory' | 'assistant' | 'task'): Tag[] {
    const tableName = this.getTableNameForEntity(entityType);
    const stmt = this.db.prepare(`
      SELECT t.* 
      FROM ${tableName} et
      JOIN tags t ON et.tag_id = t.id
      WHERE et.${entityType}_id = ?
    `);
    return stmt.all(entityId) as Tag[];
  },

  // Associate a tag with an entity
  async addTagToEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      INSERT INTO ${tableName} (${entityType}_id, tag_id)
      VALUES (?, ?)
    `);

    try {
      stmt.run(entityId, tagId);
      return true;
    } catch (error) {
      console.error('Error adding tag to entity:', error);
      return false;
    }
  },

  // Remove a tag from an entity
  async removeTagFromEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      DELETE FROM ${tableName}
      WHERE ${entityType}_id = ? AND tag_id = ?
    `);

    const result = stmt.run(entityId, tagId);
    return result.changes > 0;
  },

  // Utility: Map entity type to table name
  getTableNameForEntity(entityType: 'memory' | 'assistant' | 'task'): string {
    const tableMap = {
      memory: 'memory_tags',
      assistant: 'assistant_tags',
      task: 'task_tags',
    };
    return tableMap[entityType];
  },
}" -> "addTagToEntity";
  "tagExtraService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override the database instance
  },

  // Fetch tags associated with an entity
  getTagsByEntity(entityId: string, entityType: 'memory' | 'assistant' | 'task'): Tag[] {
    const tableName = this.getTableNameForEntity(entityType);
    const stmt = this.db.prepare(`
      SELECT t.* 
      FROM ${tableName} et
      JOIN tags t ON et.tag_id = t.id
      WHERE et.${entityType}_id = ?
    `);
    return stmt.all(entityId) as Tag[];
  },

  // Associate a tag with an entity
  async addTagToEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      INSERT INTO ${tableName} (${entityType}_id, tag_id)
      VALUES (?, ?)
    `);

    try {
      stmt.run(entityId, tagId);
      return true;
    } catch (error) {
      console.error('Error adding tag to entity:', error);
      return false;
    }
  },

  // Remove a tag from an entity
  async removeTagFromEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      DELETE FROM ${tableName}
      WHERE ${entityType}_id = ? AND tag_id = ?
    `);

    const result = stmt.run(entityId, tagId);
    return result.changes > 0;
  },

  // Utility: Map entity type to table name
  getTableNameForEntity(entityType: 'memory' | 'assistant' | 'task'): string {
    const tableMap = {
      memory: 'memory_tags',
      assistant: 'assistant_tags',
      task: 'task_tags',
    };
    return tableMap[entityType];
  },
}" -> "removeTagFromEntity";
  "tagExtraService = {
  db: new Database(':memory:'),

  setDb(newDb: Database.Database) {
    this.db = newDb; // Override the database instance
  },

  // Fetch tags associated with an entity
  getTagsByEntity(entityId: string, entityType: 'memory' | 'assistant' | 'task'): Tag[] {
    const tableName = this.getTableNameForEntity(entityType);
    const stmt = this.db.prepare(`
      SELECT t.* 
      FROM ${tableName} et
      JOIN tags t ON et.tag_id = t.id
      WHERE et.${entityType}_id = ?
    `);
    return stmt.all(entityId) as Tag[];
  },

  // Associate a tag with an entity
  async addTagToEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      INSERT INTO ${tableName} (${entityType}_id, tag_id)
      VALUES (?, ?)
    `);

    try {
      stmt.run(entityId, tagId);
      return true;
    } catch (error) {
      console.error('Error adding tag to entity:', error);
      return false;
    }
  },

  // Remove a tag from an entity
  async removeTagFromEntity(entityId: string, tagId: string, entityType: 'memory' | 'assistant' | 'task'): Promise<boolean> {
    const tableName = this.getTableNameForEntity(entityType);

    const stmt = this.db.prepare(`
      DELETE FROM ${tableName}
      WHERE ${entityType}_id = ? AND tag_id = ?
    `);

    const result = stmt.run(entityId, tagId);
    return result.changes > 0;
  },

  // Utility: Map entity type to table name
  getTableNameForEntity(entityType: 'memory' | 'assistant' | 'task'): string {
    const tableMap = {
      memory: 'memory_tags',
      assistant: 'assistant_tags',
      task: 'task_tags',
    };
    return tableMap[entityType];
  },
}" -> "getTableNameForEntity";
  "services" -> "tag.service.ts";
  "tagService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  /**
   * Add a new tag.
   */
  async addTag(tag: Omit<Tag, 'id'>): Promise<string> {
    const id = generateUniqueId();

    const stmt = this.db.prepare(`
      INSERT INTO tags (id, name)
      VALUES (?, ?)
    `);

    stmt.run(id, tag.name);

    return id;
  },

  /**
   * Remove a tag by ID.
   */
  async removeTag(tagId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM tags WHERE id = ?');
    stmt.run(tagId);
  },

  /**
   * Update an existing tag.
   */
  async updateTag(id: string, updates: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const stmt = this.db.prepare(`
      UPDATE tags
      SET name = COALESCE(?, name)
      WHERE id = ?
    `);

    stmt.run(updates.name || null, id);
  },

  /**
   * Fetch a tag by ID.
   */
  async getTagById(tagId: string): Promise<Tag | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags WHERE id = ?
    `);

    const result = stmt.get(tagId);
    return result ? (result as Tag) : null;
  },

  /**
   * Fetch all tags.
   */
  async getAllTags(): Promise<Tag[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags
    `);

    return stmt.all() as Tag[];
  },
}" -> "setDb";
  "tagService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  /**
   * Add a new tag.
   */
  async addTag(tag: Omit<Tag, 'id'>): Promise<string> {
    const id = generateUniqueId();

    const stmt = this.db.prepare(`
      INSERT INTO tags (id, name)
      VALUES (?, ?)
    `);

    stmt.run(id, tag.name);

    return id;
  },

  /**
   * Remove a tag by ID.
   */
  async removeTag(tagId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM tags WHERE id = ?');
    stmt.run(tagId);
  },

  /**
   * Update an existing tag.
   */
  async updateTag(id: string, updates: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const stmt = this.db.prepare(`
      UPDATE tags
      SET name = COALESCE(?, name)
      WHERE id = ?
    `);

    stmt.run(updates.name || null, id);
  },

  /**
   * Fetch a tag by ID.
   */
  async getTagById(tagId: string): Promise<Tag | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags WHERE id = ?
    `);

    const result = stmt.get(tagId);
    return result ? (result as Tag) : null;
  },

  /**
   * Fetch all tags.
   */
  async getAllTags(): Promise<Tag[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags
    `);

    return stmt.all() as Tag[];
  },
}" -> "addTag";
  "tagService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  /**
   * Add a new tag.
   */
  async addTag(tag: Omit<Tag, 'id'>): Promise<string> {
    const id = generateUniqueId();

    const stmt = this.db.prepare(`
      INSERT INTO tags (id, name)
      VALUES (?, ?)
    `);

    stmt.run(id, tag.name);

    return id;
  },

  /**
   * Remove a tag by ID.
   */
  async removeTag(tagId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM tags WHERE id = ?');
    stmt.run(tagId);
  },

  /**
   * Update an existing tag.
   */
  async updateTag(id: string, updates: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const stmt = this.db.prepare(`
      UPDATE tags
      SET name = COALESCE(?, name)
      WHERE id = ?
    `);

    stmt.run(updates.name || null, id);
  },

  /**
   * Fetch a tag by ID.
   */
  async getTagById(tagId: string): Promise<Tag | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags WHERE id = ?
    `);

    const result = stmt.get(tagId);
    return result ? (result as Tag) : null;
  },

  /**
   * Fetch all tags.
   */
  async getAllTags(): Promise<Tag[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags
    `);

    return stmt.all() as Tag[];
  },
}" -> "removeTag";
  "tagService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  /**
   * Add a new tag.
   */
  async addTag(tag: Omit<Tag, 'id'>): Promise<string> {
    const id = generateUniqueId();

    const stmt = this.db.prepare(`
      INSERT INTO tags (id, name)
      VALUES (?, ?)
    `);

    stmt.run(id, tag.name);

    return id;
  },

  /**
   * Remove a tag by ID.
   */
  async removeTag(tagId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM tags WHERE id = ?');
    stmt.run(tagId);
  },

  /**
   * Update an existing tag.
   */
  async updateTag(id: string, updates: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const stmt = this.db.prepare(`
      UPDATE tags
      SET name = COALESCE(?, name)
      WHERE id = ?
    `);

    stmt.run(updates.name || null, id);
  },

  /**
   * Fetch a tag by ID.
   */
  async getTagById(tagId: string): Promise<Tag | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags WHERE id = ?
    `);

    const result = stmt.get(tagId);
    return result ? (result as Tag) : null;
  },

  /**
   * Fetch all tags.
   */
  async getAllTags(): Promise<Tag[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags
    `);

    return stmt.all() as Tag[];
  },
}" -> "updateTag";
  "tagService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  /**
   * Add a new tag.
   */
  async addTag(tag: Omit<Tag, 'id'>): Promise<string> {
    const id = generateUniqueId();

    const stmt = this.db.prepare(`
      INSERT INTO tags (id, name)
      VALUES (?, ?)
    `);

    stmt.run(id, tag.name);

    return id;
  },

  /**
   * Remove a tag by ID.
   */
  async removeTag(tagId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM tags WHERE id = ?');
    stmt.run(tagId);
  },

  /**
   * Update an existing tag.
   */
  async updateTag(id: string, updates: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const stmt = this.db.prepare(`
      UPDATE tags
      SET name = COALESCE(?, name)
      WHERE id = ?
    `);

    stmt.run(updates.name || null, id);
  },

  /**
   * Fetch a tag by ID.
   */
  async getTagById(tagId: string): Promise<Tag | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags WHERE id = ?
    `);

    const result = stmt.get(tagId);
    return result ? (result as Tag) : null;
  },

  /**
   * Fetch all tags.
   */
  async getAllTags(): Promise<Tag[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags
    `);

    return stmt.all() as Tag[];
  },
}" -> "getTagById";
  "tagService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  /**
   * Add a new tag.
   */
  async addTag(tag: Omit<Tag, 'id'>): Promise<string> {
    const id = generateUniqueId();

    const stmt = this.db.prepare(`
      INSERT INTO tags (id, name)
      VALUES (?, ?)
    `);

    stmt.run(id, tag.name);

    return id;
  },

  /**
   * Remove a tag by ID.
   */
  async removeTag(tagId: string): Promise<void> {
    const stmt = this.db.prepare('DELETE FROM tags WHERE id = ?');
    stmt.run(tagId);
  },

  /**
   * Update an existing tag.
   */
  async updateTag(id: string, updates: Partial<Omit<Tag, 'id'>>): Promise<void> {
    const stmt = this.db.prepare(`
      UPDATE tags
      SET name = COALESCE(?, name)
      WHERE id = ?
    `);

    stmt.run(updates.name || null, id);
  },

  /**
   * Fetch a tag by ID.
   */
  async getTagById(tagId: string): Promise<Tag | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags WHERE id = ?
    `);

    const result = stmt.get(tagId);
    return result ? (result as Tag) : null;
  },

  /**
   * Fetch all tags.
   */
  async getAllTags(): Promise<Tag[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM tags
    `);

    return stmt.all() as Tag[];
  },
}" -> "getAllTags";
  "services" -> "task.service.ts";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "setDb";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "getTaskById";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "getAllTasks";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "addTask";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "updateTask";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "deleteTask";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "getTasksByStatus";
  "taskService = {
  db: new Database(':memory:'), // Default database instance

  setDb(newDb: Database.Database) {
    this.db = newDb; // Allow overriding the database instance
  },

  // Fetch all tasks
  getTaskById(id: string): Task | null {
    const stmt = this.db.prepare('SELECT * FROM tasks WHERE id = ?');
    const result = stmt.get(id) as TaskRow;

    if (!result) return null;

    return {
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    } as Task;
  },

  getAllTasks(): Task[] {
    const stmt = this.db.prepare('SELECT * FROM tasks');
    const results = stmt.all() as TaskRow[];

    return results.map((result) => ({
      ...result,
      inputData: result.inputData ? JSON.parse(result.inputData) : undefined,
      outputData: result.outputData ? JSON.parse(result.outputData) : undefined,
      createdAt: new Date(result.createdAt),
      updatedAt: new Date(result.updatedAt),
    })) as Task[];
  },

  // Add a new task
  async addTask(task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const id = generateUniqueId(); // Generate a unique ID for the task
    const createdAt = new Date().toISOString();
    const updatedAt = createdAt;

    const stmt = this.db.prepare(`
      INSERT INTO tasks (id, description, assignedAssistant, status, inputData, outputData, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(id, task.description, task.assignedAssistant, task.status, JSON.stringify(task.inputData || null), JSON.stringify(task.outputData || null), createdAt, updatedAt);

    return id;
  },

  // Update an existing task
  async updateTask(id: string, updates: Partial<Omit<Task, 'id' | 'createdAt' | 'updatedAt'>>): Promise<boolean> {
    const existingTask = this.db.prepare('SELECT * FROM tasks WHERE id = ?').get(id) as Task | undefined;

    if (!existingTask) {
      throw new Error(`Task with ID ${id} not found.`);
    }

    const stmt = this.db.prepare(`
      UPDATE tasks
      SET
        description = COALESCE(?, description),
        assignedAssistant = COALESCE(?, assignedAssistant),
        status = COALESCE(?, status),
        inputData = COALESCE(?, inputData),
        outputData = COALESCE(?, outputData),
        updatedAt = ?
      WHERE id = ?
    `);

    stmt.run(
      updates.description || null,
      updates.assignedAssistant || null,
      updates.status || null,
      updates.inputData ? JSON.stringify(updates.inputData) : null,
      updates.outputData ? JSON.stringify(updates.outputData) : null,
      new Date().toISOString(), // updatedAt
      id
    );

    return true;
  },

  // Delete a task by ID
  async deleteTask(id: string): Promise<boolean> {
    const stmt = this.db.prepare(`
      DELETE FROM tasks
      WHERE id = ?
    `);

    const result = stmt.run(id);

    return result.changes > 0; // Returns true if the task was deleted
  },

  // Fetch tasks by status
  getTasksByStatus(status: Task['status']): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE status = ?
    `);

    return stmt.all(status) as Task[];
  },

  // Fetch tasks assigned to a specific assistant
  getTasksByAssistant(assistantId: string): Task[] {
    const stmt = this.db.prepare(`
      SELECT * 
      FROM tasks
      WHERE assignedAssistant = ?
    `);

    return stmt.all(assistantId) as Task[];
  },
}" -> "getTasksByAssistant";
  "services" -> "unique-id.service.ts";
  "unique-id.service.ts" -> "generateUniqueId";
  "tests" -> "integration";
  "integration" -> "gpt-api-chat-completion.integration.test.ts";
  "integration" -> "gpt-assistant.integration.test.ts";
  "functionParameters: FunctionParameters = {
    lalala: () => {
      return 'trololol';
    },
  }" -> "lalala";
  "integration" -> "gpt-threads.integration.test.ts";
  "tests" -> "unit";
  "unit" -> "gpt-tests";
  "gpt-tests" -> "gpt-api-thread.example.ts";
  "gpt-api-thread.example.ts" -> "addMessage";
  "gpt-api-thread.example.ts" -> "runAssistant";
  "gpt-api-thread.example.ts" -> "runAssistantAndPoll";
  "gpt-api-thread.example.ts" -> "getAllMessages";
  "gpt-api-thread.example.ts" -> "extractAssistantResponse";
  "gpt-api-thread.example.ts" -> "getAssistantResponse";
  "gpt-api-thread.example.ts" -> "getRunResults";
  "gpt-api-thread.example.ts" -> "getLastAssistantMessage";
  "gpt-api-thread.example.ts" -> "queryAssistant";
  "gpt-api-thread.example.ts" -> "addMessages";
  "gpt-api-thread.example.ts" -> "getMessages";
  "gpt-api-thread.example.ts" -> "initializeRun";
  "gpt-api-thread.example.ts" -> "pollRunStatus";
  "gpt-api-thread.example.ts" -> "addUserPrompt";
  "gpt-api-thread.example.ts" -> "promptAssistant";
  "gpt-api-thread.example.ts" -> "promptAssistantSimple";
  "gpt-tests" -> "gpt-assistant-with-functions.example.ts";
  "gpt-tests" -> "gpt-assistant.test.ts";
  "gpt-tests" -> "gpt-crud.example.ts";
  "unit" -> "other-tests";
  "other-tests" -> "assistant.queries.test.ts";
  "other-tests" -> "gpt-api-model.helper.test.ts";
  "unit" -> "service-tests";
  "service-tests" -> "assistant-full.service.test.ts";
  "service-tests" -> "assistant.service.test.ts";
  "service-tests" -> "database.test.ts";
  "service-tests" -> "feedback.service.test.ts";
  "service-tests" -> "focused-memory.service.test.ts";
  "service-tests" -> "memory-extra.service.test.ts";
  "service-tests" -> "memory-focus-rule.service.test.ts";
  "service-tests" -> "memory.service.test.ts";
  "service-tests" -> "owned-memory.service.test.ts";
  "service-tests" -> "relationship-graph.service.test.ts";
  "service-tests" -> "tag-extra.service.test.ts";
  "service-tests" -> "tag.service.test.ts";
  "service-tests" -> "task.service.test.ts";
  "unit" -> "test-db-insert.helper.ts";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertTags";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertFullAssistantSetup";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertAssistant";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertMemoryFocusRule";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertFocusedMemory";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertMemories";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertMemory";
  "insertHelpers = {
  insertTags(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO tags (id, name)
      VALUES ('1', 'Tag1'), ('2', 'Tag2')
    `
    ).run();

    db.prepare(
      `
      INSERT OR IGNORE INTO assistant_tags (assistant_id, tag_id)
      VALUES (?, ?), (?, ?)
    `
    ).run(assistantId, '1', assistantId, '2');
  },

  insertFullAssistantSetup(db: Database.Database, assistantId: string = '1') {
    // Insert the assistant
    this.insertAssistant(db, assistantId);

    // Insert tags and associate them with the assistant
    this.insertTags(db, assistantId);

    // Insert a memory focus rule for the assistant
    this.insertMemoryFocusRule(db, '1', assistantId);

    // Insert multiple memories and associate them with the focus rule
    this.insertMemories(db); // Inserts multiple memories
    this.insertFocusedMemory(db, '1', '2'); // Associate second memory
  },

  insertAssistant(db: Database.Database, assistantId: string = '1') {
    db.prepare(
      `
      INSERT OR IGNORE INTO assistants (id, name, description, type, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `
    ).run(assistantId, `Test Assistant ${assistantId}`, `Description for Assistant ${assistantId}`, 'completion', new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRule(db: Database.Database, ruleId: string = '1', assistantId: string = '1') {
    this.insertAssistant(db, assistantId);

    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?)
    `
    ).run(ruleId, assistantId, 5, new Date().toISOString(), new Date().toISOString());
  },

  insertFocusedMemory(db: Database.Database, memoryFocusId: string, memoryId: string): void {
    const stmt = db.prepare(
      `
      INSERT OR IGNORE INTO focused_memories (memory_focus_id, memory_id)
      VALUES (?, ?)
    `
    );
    try {
      stmt.run(memoryFocusId, memoryId);
    } catch (error) {
      console.error(`Error inserting focused memory (memoryFocusId: ${memoryFocusId}, memoryId: ${memoryId}):`, error);
    }
  },

  insertMemories(db: Database.Database) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES ('1', 'knowledge', 'Memory Description', ?, ?),
           ('2', 'knowledge', 'Another Memory Description', ?, ?)
  `
    ).run(new Date().toISOString(), new Date().toISOString(), new Date().toISOString(), new Date().toISOString());
  },

  insertMemory(db: Database.Database, id: string) {
    // Insert standalone memories
    db.prepare(
      `
    INSERT OR IGNORE INTO memories (id, type, description, createdAt, updatedAt)
    VALUES (?, 'knowledge', 'Memory Description', ?, ?)
  `
    ).run(id, new Date().toISOString(), new Date().toISOString());
  },

  insertMemoryFocusRules(db: Database.Database) {
    db.prepare(
      `
      INSERT OR IGNORE INTO memory_focus_rules (id, assistant_id, maxResults, relationshipTypes, priorityTags, createdAt, updatedAt)
      VALUES ('1', '1', 10, '[]', '[]', ?, ?)
    `
    ).run(new Date().toISOString(), new Date().toISOString());
  },
}" -> "insertMemoryFocusRules";
  "unit" -> "test-db-return.helper.ts";
  "unit" -> "test-db.helper.ts";
  "test-db.helper.ts" -> "TestDbHelper";
  "TestDbHelper" -> "BetterSqlite3.Database | null";
  "unit" -> "test-object.helper.ts";
  "unit" -> "transformer-tests";
  "transformer-tests" -> "assistant-full.transformer.test.ts";
  "transformer-tests" -> "assistant.transformer.test.ts";
  "transformer-tests" -> "memory-focus-rule.transformer.test.ts";
  "transformer-tests" -> "memory.transformer.test.ts";
  "transformers" -> "assistant-full.transformer.ts";
  "assistant-full.transformer.ts" -> "transformFullAssistantResult";
  "transformers" -> "assistant.transformer.ts";
  "assistant.transformer.ts" -> "transformAssistantRow";
  "assistant.transformer.ts" -> "transformAssistantWithDetails";
  "transformers" -> "memory-focus-rule.transformer.ts";
  "memory-focus-rule.transformer.ts" -> "transformMemoryFocusRuleRow";
  "transformers" -> "memory.transformer.ts";
  "memory.transformer.ts" -> "transformMemoryRow";
  "transformers" -> "tag.transformer.ts";
  "tag.transformer.ts" -> "transformTagRow"
}
